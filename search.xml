<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[element-ui使用el-select远程搜索]]></title>
    <url>%2F2019%2F08%2F08%2Felement-ui%E4%BD%BF%E7%94%A8el-select%E8%BF%9C%E7%A8%8B%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[使用el-select进行远程搜索一简介：el-select是element-ui框架提供的下拉框组件，当选项过多时，使用下拉菜单展示并选择内容。本节主要介绍使用el-select进行远程搜索的实现过程。1，直接上代码: 1234567891011121314151617&lt;el-header&gt; &lt;div&gt; &lt;el-row :gutter="20"&gt; &lt;el-select overflow-y:scroll :trigger-on-focus="true" @click.native="loadNotRelationProduct" v-model="value" multiple filterable remote reserve-keyword size="medium" placeholder="系统编号、名称、英文简称" :remote-method="remoteMethod" :loading="loading"&gt; &lt;el-option v-for="item in options" :key="item.productCode" :label="item.productName" value-key="item.productId" :value="item.productCode"&gt; &lt;span style="float: left"&gt;&#123;&#123; item.productName &#125;&#125;&lt;/span&gt; &lt;span style="float: right; color: #8492a6; font-size: 13px"&gt;&#123;&#123; item.productCode &#125;&#125;&lt;/span&gt; &lt;/el-option&gt; &lt;el-button slot="append" icon="el-icon-search"&gt;&lt;/el-button&gt; &lt;/el-select&gt; &lt;el-button type="primary" @click="relate" icon="el-icon-plus"&gt;添 加&lt;/el-button&gt; &lt;/el-row&gt; &lt;/div&gt;&lt;/el-header&gt; 二，属性字段解析：overflow-y:scroll 当下拉项太多时，出现滚动条进行上下滑动 @click.native=”loadNotRelationProduct” 当点击下拉框时触发loadNotRelationProduct方法，加载数据 v-model=”value” 可以理解为双向绑定的数据，当选择后，得到框里的值，可以传到后台进行处理 为了启用远程搜索，需要将filterable和remote设置为true，同时传入一个remote-method。remote-method为一个方法，它会在输入值发生变化时调用，参数为当前输入值。需要注意的是，如果el-option是通过v-for指令渲染出来的，此时需要为el-option添加key属性，且其值需具有唯一性，比如此例中的item.productCode 123456&lt;span style="float: left"&gt;&#123;&#123; item.productName &#125;&#125;&lt;/span&gt;&lt;span style="float: right; color: #8492a6; font-size: 13px"&gt;&#123;&#123;item.productCode &#125;&#125;&lt;/span&gt; 这俩个span代表着当下拉框展示数据时，要显示数据的样式，以及显示哪些数据。第一个代表下拉框的左侧显示系统名称，第二个表示下拉框右侧显示系统编号 remoteMethod方法：在输入框的值发生变化时，会调用这个方法，我们分析一下该方法的作用: 参数query代表输入框中的值，如果这个值不是空，那么就会根据这个值，将list中与该值相似的值拿出来 并赋值到options数组中，返回。 有几点需要注意： ​ 1，this.list: 代表着所有数据，比如从后台查出的所有系统的信息 ​ 2，this.options: 代表的是当用关键字搜索，返回的数据。 ​ 3，官网给出的只能根据一个字段来远程搜索，比如根据系统名称搜索，那现在我既要根据系统名称搜索， ​ 又要根据系统编号进行搜索，该怎么做呢？ ​ 只需要在return 后面的返回代码改一下，原来只有item.productName,现在只要把多个字段给加起来 ​ 就解决了。 1234567891011121314remoteMethod(query) &#123; if (query !== '') &#123; this.loading = true; setTimeout(() =&gt; &#123; this.loading = false; this.options = this.list.filter(item =&gt; &#123; return (item.productName+item.productCode+item.productEnShortName).toLowerCase() .indexOf(query.toLowerCase()) &gt; -1; &#125;); &#125;, 200); &#125; else &#123; this.options = []; &#125; &#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>element-ui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法]]></title>
    <url>%2F2019%2F07%2F02%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试通]]></title>
    <url>%2F2019%2F04%2F01%2F%E9%9D%A2%E8%AF%95%E9%80%9A%2F</url>
    <content type="text"><![CDATA[面试题总结一，java语法以及特性1，Java中接口和抽象类的区别1.1接口1，可以有变量和方法也可以不含有 2，变量会被隐式的指定为 public static final ,并且只能是public static final 3，方法会被隐式的指定为 public abstract 方法并且只能是 public abstract 4，接口中所有的方法不能有具体的实现，必须是抽象方法 5，可以看出接口是一种极度抽象的类型，他比抽象类更抽象 6，一般情况下不会在接口中定义变量 7，JDK8中接口可以有static方法，和default方法，在不破坏java架构的的情况下，可以往接口中增加新方法 1.2抽象类1，一般含有抽象方法，也可以不含有 2，抽象类前面，必须使用abstract关键字来修饰 3，抽象类不能用来创建对象 4，子类如果继承抽象类，子类必须实现抽象类中的所有抽象方法，否则子类依旧是抽象类。 5，抽象类实现接口，可以不实现接口中的抽象方法。 1.3抽象方法1，抽象方法是一种特殊的方法，它只有声明没有实现 1.4抽象类和接口的区别1，抽象类表示的是一种继承关系，一个类只能使用一次继承关系，却可以实现多个接口 2，抽象类可以有数据成员变量，也可以有非抽象的成员方法；而接口中只能有static final的数据成员，所有成员的方法都 是abstract 3，实现抽象类和接口的类，必须实现其中所有的方法，如果子类没有抽象类中的所有抽象方法，则子类必须声明为抽象类；非抽象类的子类实现，则必须把接口中的方法全部实现 4，接口可以继承接口，此时不需要实现父类接口 5，抽象类中可以有非抽象方法，接口中则不能有实现方法，（jdk1.7不可以，jdk1.8可以有实现） 2，抽象类和普通类的区别1，抽象方法必须声明为public修饰，或者protected修饰，因为如果用private修饰，子类就无法实现该方法，缺省情况下默认的是public 2，抽象类不能创建对象，而普通类可以 3，子类必须实现抽象类的抽象方法，否则子类也是一个抽象类；而普通类没有抽象方法 3，方法签名1，方法签名包括俩部分：方法名称，参数列表（方法的参数数量，顺序，类型） 2，注意方法签名不包括方法的返回值类型，返回值，和方法修饰符。 4，方法宗量1，方法的接受者和方法的参数，统称为方法的宗量 2，根据分派基于多少种宗量，可以将分派划分为单分派，和多分派俩种 3，单分派是根据一个宗量对目标方法进行选择，多分派是根据多于一个宗量对目标方法进行选择 5，注解5.1，定义1，官网定义：Java注解用于为Java代码提供元数据，作为元数据，注解不直接影响代码执行。 2，通俗解释：如果代码有生命，那么注解就是对于代码中某些鲜活个体贴上去的一张标签，简化就是注解如同一张标签 3，注解的定义： 1234public @interface TestAnnotation&#123; //它的形式和接口的定义方式有些相似，只是在前面多一个@符号 //这段代码表示创建了一个名字为 TestAnnotation的注解&#125; 5.2，使用1，创建一个类Test，然后在该类的上方加上@TestAnnotation就可以使用TestAnnotation注解了，可以理解为，将TestAnnotation这张标签贴到Test这个类上面。 5.3，元注解元注解是可以注解到注解上的注解，或者说元注解是一种基本注解，但是它能够应用在其他注解上面，或者也可以这么理解，元注解也是一张标签，但是它是一张特殊的标签，他的作用和目的是给其他普通的标签进行解释说明的，元注解有五种，分别是： @Retention，@Documented，@Target，@Inherited，@Repetable 5.3.1@Retention(保留滞留)1，当这个注解应用在一个注解上时，它解释说明了这个注解的存活时间 2，它的取值范围是： ​ RetentionPolicy.SOURCE:注解只在源码阶段保留，在编译器进行编译时，它将被忽略丢弃。 ​ RetentionPolicy.CLASS：注解只保留到编译进行的时候，它并不会被加载到虚拟机中 ​ RetentionPolicy.RUNTIME：注解可以保留到程序运行的时候，它会被加载到虚拟机中，所以在程序运行时，可以获取他们。 3，或者可以这么理解：@Retention去给一个注解解释的时候，指定了这个注解的存活时间，指明了它的时间周期。 1234@Retention(RetentionPolicy.RUNTIME)public @interface TestAnnotation&#123; //指定了TestAnnotation注解可以在运行期间可以被获取到，因此它的生命周期很长。&#125; 5.3.2@Documented(记录，备有证明文件的)它的作用是能将注解中的元素包含到Javadoc中 5.3.3@Target（目标）1，@Target指定了注解运行的地方，当一个注解被@Target注解时，这个注解就被限定了应用的场景。 2，比如注解到方法，类，方法参数等等 3， 5.3.4@Inherited（继承）如果一个父类被@Inherited注解过的注解，则它的子类没有任何注解的话，这个子类就继承了父类的注解。 123456789@Inherited@Retention（RetentionPolicy.RUNTIME）public @interface TestInherited &#123;&#125;@TestInheritedpublic class A&#123;&#125;public class B extends A &#123;&#125;那么B也有了这个注解。 5.3.5@Repeatable（可重复）1，jdk1.8加入的新特性 2，通常注解的值是可重复的，比如一个人既是画家又是经理 12345678910111213public @interface Persons&#123; Persion[] value();&#125;@Repeatable(Persons.class)public @interface Person&#123; String role default "";&#125;@Person(role = "PM")@Person(role = "artist")public class SuperMan&#123; &#125; 上面代码中，@Repeatable注解了Person类，而@Repeatable后面的括号中的类，相当于一个容器注解 什么是容器注解：就是用来存放其他注解的地方，它本身也是一个注解 Persons注解就是一个容器注解，按照规范，它里面必须有一个value属性，属性类型是被@Repeatable注解过的注解数组，注意它是数组 5.3.6注解属性1，注解的属性，也叫作成员变量，注解只有成员变量，没有方法 2，注解中的成员变量在注解的定义中，以 “无形参的方式”来声明： ​ 其方法名定义了该成员变量的名字 ​ 其返回值定义了该成员变量的类型 ​ 1234public @interface TestAnnotation&#123; int id(); String msg();&#125; 代码中定义了TestAnnotatio注解中，拥有id 和 msg这俩个属性，在使用的时候，我们应该给他们赋值。 属性赋值的方法，如下： 12@TestAnnotation(id=3,msg="hello annotation")public class Test1&#123;&#125; 注意：在注解中定义属性时，它的类型必须死8中基本数据类型，外加：类，接口，注解，和他们的数组。 注解中的属性可以有默认值，默认值需要用default来声明。 123456@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface TestAnnotation&#123; public int id() default-1; public String msg() default "hello";&#125; id属性的默认值为-1，msg属性默认值为hello 它可以这样用： 12@TestAnnotationpublic class Test2&#123;&#125; 因为有默认值，所以可以不用在@TestAnnotation的括号里面赋值了， 另外还有一种情况，如果一个注解只有一个名字为value的属性时，使用这个注解时可以直接把属性值写到括号里，如下： 123public @interface DirectWriter&#123; String value();&#125; 上面的代码中，DirectWriter注解只有一个value属性，所以使用时，可以直接写属性值，而不用写（属性名字=属性值），例如： 123456@DirectWriter("hello")int num;效果和下面的一样：@DirectWriter(value="hello")int num; 注解没有任何属性，此时使用这个注解的时候连括号也可以省略： 123456public @interface NoProperty&#123;&#125;使用这个注解的时候：@NoPropertypublic void testProperty() 5.4，java内置注解Java语言本身提供了几个现成的注解：@Deprecated，@Override，@SuppressWarnings，@SafeVarargs，@Functionallnterface 1，@Override用来指定方法重写的，它强制一个子类必须覆盖父类的方法 只能修饰方法，不能修饰其他程序元素 2，@Deprecated用于表示某个程序元素（类，方法，接口等）已过时 当程序使用过时的类，方法时，编译器会给出警告， 3，@SuppressWarnings抑制编译器警告，指示，被该注解修饰的程序元素（以及所有的子元素），取消显示指定的编译器警告，会一直作用于该程序元素的所有子元素。 4，SafeVarargsjava7中的堆污染：当把一个不带泛型的对象赋值给一个带泛型的变量时，往往会发生堆污染。 使用该注解，一直引发该警告的方法或构造器。 5，@Functionallnterface：java8中的函数式接口 java8规定：如果接口中只有一个抽象方法，该接口就是函数式接口 @FunctionalInterface就是用来指定某个接口必须是函数式接口 函数式接口就是为了java8的lambda表达式准备的，java8允许使用Lambda表达式创建函数式接口的实例，因此java8专门增加了@FunctionalInterface 只能修饰接口，不能修饰其他程序元素。 6.Java中equals和 ==的区别是什么？1，==用来判断俩个对象的地址是否相同，即是否指同一个对象，比较的是真正意义是指针操作 2，equals用来比较的是俩个对象内容时候相等，由于所有的类都是继承自Object类的，所以适用于所有的对象，如果没有重写该方法的话，调用的仍然是Object中的方法，而Object发中的equals方法返回的却是==操作 7，Java8中新增的lamda表达式7.1什么是λ表达式1，λ表达式是一个带有参数的代码块 2，当你想要代码块在以后的某个时间点执行时，可以使用λ表达式 3，λ表达式可以被转化为函数式接口 4，λ表达式可以在闭包作用域中有效的访问final变量 5，方法和构造器引用可以引用方法或构造器，但无须调用他们 12345678910111213141516171819//1,不需要参数，返回值为5() -&gt; 5//2，接受一个参数（数字类型），返回值其2倍的值x -&gt; 2 * x//3,接受2个参数（数字），并返回他们的差值(x,y) -&gt; x-y//4,接受2个int整数，返回他们的和(int x,int y) -&gt; x + y//5,接受一个string对象，并在控制台打印，不返回任何值(String s) -&gt; System.out.print(s)//以前的循环方式： for(String player : players&#123; System.out.print(player+""); &#125;//使用lamda表达式以及函数操作（functional operation） players.forEach((player) -&gt; System.out.print(player+""));//在java8中使用双冒号操作符players.forEach(System.out::println); 6,Lambda表达式支持将代码块作为方法参数，允许使用使用更简洁的代码来创建只有一个抽象方法的借口（被称为函数式接口） 7，Lambda表达式完全可用于简化创建匿名内部类对象 当使用λ表达式代替匿名内部类创建对象时，Lambda表达式的代码块，将会代替实现抽象方法的方法体，Lambda表达式就相当于一个匿名方法。 8，Lambda表达式的主要作用就是代替匿名内部类的繁琐语法，由三部分构成： 形参列表：允许省略形参类型，如果形参列表中只有一个参数，甚至连形参列表的圆括号都可以省略。 箭头：（-&gt;）必须通过英文中画线号和大于符号组成 代码块：如果代码块只包含一条语句，Lambda表达式允许省略代码块的花括号，那么这条语句就不要用花括号表示语句结束，Lamdda代码块只有一条return语句，甚至可以省略return关键字，Lambda表达式需要返回值，而它的代码块中仅有一条省略了return语句，Lambda表达式会自动返回这条语句的值 8，char可以存储汉字吗1，char型变量是用来存储Unicode编码的字符，Unicode编码集中包含了汉字，所以，char型变量可以用来存储汉字。 2，如果某个特殊的汉字没有包含在Unicode字符集中，那么这个char型变量中就不能存储这个特殊汉字 3，补充：Unicode编码占用俩个字节，所以char类型的变量也是占用俩个字节。 9，Java序列化，什么时候需要修改序列化版本号？当俩个进程在远程通信时，彼此可以发送各种类型的数据，无论何种数据类型的数据，都会以二进制序列的形式在网络上传送，发送方需要把这个Java对象转换为直接序列，才能在网络上传送，接收方则需要把字节序列再恢复为Java对象，把Java对象转换为字节序列的过程称为对象的序列化，把字节序列恢复为Java对象的过程称为对象的反序列化 9.1序列化规则1，java序列化机制为了节省磁盘空间，具有特定的存储规则，当写入文件的为同一个对象时，并不会将对象的内容进行存储，而只是再次存储一份引用。 2，一次性写入传输对象修改前和修改后的状态，结果修改后的状态没有保存，还是修改前的状态，jvm根据引用关系直到，已经有一个相同的对象写入文件，因此只保存第二次写的引用，都是第一次保存的对象，在使用一个文件多次writeObject需要特别注意。 3，jvm时候允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是，俩个类的序列化id是否一致，俩个类的功能代码完全一致，但是序列化id不一致，则他们无法相互序列化和反序列化 4，Java序列化是将一个对象编码成一个字节流，反序列化将字节流编码转换成一个对象序列化是Java中实现持久化存储的一种方法 5，Java序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的，在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应类的进行对比，如果相同认为一致，可以进行反序列化，否则就会出现序列化版本不一致的异常。 9.2,什么时候需要修改序列化版本号1,对象的序列化主要有俩种用途： 把对象的字节序列永久的保存到硬盘上，通常存放在一个文件中。 在网络上传送对象的字节序列 2，显示地定义serialVersionUID有俩种用途： 在某些场合，希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的serialVersionUID；在某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有不同的serialVersionUID。 当你序列了一个类实例后，希望更改一个字段或者添加一个字段，不设置serialVersionUID，所做的任何更改都会导致无法反序列化旧有实例，并且在反序列化时抛出了一个异常，如果你添加了serialVersionUID，在反序列旧有实例时，新添加的或者更改的字段值将设为初始化值，字段被删除将不设置。 10，try catch finally return 的情况1，不管有没有发生异常，finally每次都会执行 2，如果try中没有异常发生，而finally中有return，不管try中有没有return，则从finally中返回值 3，如果try中没有发生异常，finally中没return，则在return前先缓存try中的return结果，再执行finally中代码。 4，如果try中有异常，catch中有return，finally没return，则从catch中的return返回 5，如果try中有异常，catch中没return，则从finally中的return返回 6，任何执行try或者catch中的return语句之后，在返回之前，如果finally存在的话，都会先执行finally语句 7，如果finally中有return那么程序就return了，所以finally中的return是一定会被return的 8，编译器把finally中的return实现为一个warning 11，java中的泛型，泛型擦除1，泛型本质是参数化类型，也就是说变量的类型是一个参数，在使用时再指定为具体类型，泛型可以用于类，接口，方法，通过使用泛型可以使代码更简单，安全，然而java中的泛型使用了类型的擦除，所以只是伪泛型，类型参数只存在于编译期，在运行时，java的虚拟机并不知道泛型的存在， 2，包括： ​ 泛型类 泛型方法 泛型接口 3，通配符的出现是为了指定泛型中的类型范围 通配符有三种形式 ​ &lt;?&gt;：被称作无限定的通配符，提供了只读的功能，只保留与具体类型无关的功能，它不管转载在这个容器内的元素是什么类型，它只关心元素的数量，容器是否为空 ​ &lt;？ extends T&gt;：被称作有上限的通配符，上界不存，丧失了写的能力，只可以从里面读取 ​ &lt;? super T&gt;:被称作有下限的通配符，下界不取，丧失读的能力，只可以存入往里面存入对象 4，类型擦除： 泛型信息只存在于代码编译阶段，在进入jvm之前，与泛型相关的信息会被擦除。 参数类型是一个单独的T，那么就擦除到Object，相当于所以出现T的地方都用Object替换，所以在JVM看来，保存的变量a还是Object类型，之所以取出来自动就是我们传入的参数的类型，这是因为编译器在编译生成的字节码中插入了类型转换的代码，不需要我们手动转型了，如果参数类型有边界那么就擦除到它的第一个边界。 5，一般而言，通配符能干的事情都可以用类型参数替换 6，不接受8中基本数据类型 7，java中的泛型擦除，只在源码中存在，在编译后的字节码文件中就已经被替换为原生类型，并在相应位置插入强制类型转换。 12内部类1，内部类比外部类多使用三个访问修饰符：private，protected，static，外部类不可以用这三个修饰符。 2，非静态内部类，不能拥有静态成员 3，内部类分为四种：成员内部类，方法内部类，竞态内部类，匿名内部类。 4，成员内部类是一种与成员变量，方法，构造器和初始化块相似的类成员 5，局部内部类和匿名内部类则不是类成员 6，内部类一定是行放在一个类的类体部分 7，内部类作为其外部类的成员，所以可以使用任意访问修饰符如：private ，protected，public 12.1成员内部类1，]]></content>
      <categories>
        <category>java</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA多线程第一阶段]]></title>
    <url>%2F2019%2F02%2F25%2FJAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%2F</url>
    <content type="text"><![CDATA[JAVA多线程第一阶段1、线程介绍线程可以理解成是在进程中独立运行的子任务 ​ 注意：多线程是异步的，代码的顺序不是线程执行的顺序，线程被调用的时机是随机的，一个进程正在运行时，至少 会有一个线程在运行， 2、创建并启动线程创建线程的俩种方式： 1，继承Thread类，示例如下： 模拟俩个线程，一个从数据库读取数据，一个线程将读取到的数据写入文件中。 123456789101112131415161718192021222324252627282930313233343536package com.primeton.thread.one;public class CreateThread &#123; public static void main(String[] args) &#123; new Thread("READ-Thread")&#123; @Override public void run()&#123; readData(); &#125; &#125;.start(); new Thread("WRITE-Thread")&#123; @Override public void run()&#123; writeData(); &#125; &#125;.start(); &#125; public static void readData() &#123; System.out.println("begin readData from Database"); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("end readData from Database"); &#125; public static void writeData() &#123; System.out.println("begin writeData from file"); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("end writeData from file"); &#125;&#125; 运行结果： begin readData from Databasebegin writeData from fileend readData from Databaseend writeData from file 结论： 可以看到俩个线程同时启动了。 只有调用了start方法的线程才是启动了一个线程。 TIPS： jps查询正在运行的线程ID jconsole来启动界面来查询当前线程 3、线程的生命周期 总结： ​ 1.Java应用程序的main函数是一个线程，是被JVM启动时调用的，线程的名称是main ​ 2，实现一个线程，必须创建Thread实例，覆盖run方法，调用start方法 ​ 3，JVM启动后，有多个线程，至少有一个非守护线程。 ​ 4，当调用start方法时，此时至少有俩个线程，一个是调用你的线程比如main线程，一个是执行start方法的线程。 ​ 5，线程的生命周期： new runnable running block termate ​ 6，start方法源码：使用了一个模板方法模式，Thread类只提供了一个启动线程的方法，至于启动线程要干嘛，不知 道，所以单独抽出一个借口也就是run方法，干啥，我们去覆盖run方法去实现就好了。 4、Runnable接口介绍创建线程的第二种方式：实现Runnable接口 示例：银行窗口排队叫号实现。 12345678910111213141516171819202122232425262728293031323334353637383940package com.primeton.thread.one;public class Bank &#123; private static int ticket = 1; public void sale()&#123; while(ticket &lt;=50)&#123; System.out.println("当前窗口： "+Thread.currentThread().getName()+"---"+ticket); ticket++; &#125; &#125;&#125;class BankTest&#123; public static void main(String[] args) &#123; Bank bank = new Bank(); Runnable runnable1 = new Runnable() &#123; @Override public void run() &#123; bank.sale(); &#125; &#125;; Runnable runnable2 = new Runnable() &#123; @Override public void run() &#123; bank.sale(); &#125; &#125;; Runnable runnable3 = new Runnable() &#123; @Override public void run() &#123; bank.sale(); &#125; &#125;; Thread t1 = new Thread(runnable1); Thread t2 = new Thread(runnable2); Thread t3 = new Thread(runnable3); t1.start(); t2.start(); t3.start(); &#125;&#125; 结论： Runnable：将可执行的逻辑单元和线程控制分离出来，由不同的class负责，正好是面向对象的一个比较好的一个体现。 5、Thread API详细介绍Thread() Thread(Runnable target) Thread(Runnable target,String name) Thread(String name) Thread(ThreadGroup group) Thread(ThreadGroup group,Runnable target) Thread(ThreadGroup group,String name) Thread(ThreadGroup group,Runnable target,String name) 1,创建线程对象Thread，默认有一个线程名称，以Thread-开头，从0开始计数，构造函数Thread（） Thread-0 Thread-1 Thread-2 对应源码如下： 123456public Thread() &#123; init(null, null, "Thread-" + nextThreadNum(), 0);&#125; private static synchronized int nextThreadNum() &#123; return threadInitNumber++; &#125; 2，如果在构造Thread的时候没有传递Runnable或者没有复写Thread的run方法，该Thread将不会调用任何东西， ​ 如果传递了Runnable接口的实例，或者复写了Thread中的run方法，则会执行该方法的逻辑单元（逻辑代码） ​ 对应源码如下： 12345678910111213141516171819202122232425262728293031323334353637383940//传递了Runnable接口的实例public Thread(Runnable target) &#123; init(null, target, "Thread-" + nextThreadNum(), 0);&#125;//没有传递Runnable接口的实例public Thread() &#123; init(null, null, "Thread-" + nextThreadNum(), 0); &#125;//进入init方法private void init(ThreadGroup g, Runnable target, String name, long stackSize) &#123; init(g, target, name, stackSize, null, true);&#125;//再次进入这个init方法，部分源码：private void init(ThreadGroup g, Runnable target, String name, long stackSize, AccessControlContext acc, boolean inheritThreadLocals) &#123; if (name == null) &#123; throw new NullPointerException("name cannot be null"); &#125; this.name = name; Thread parent = currentThread(); if (g == null) &#123; /* If the security doesn't have a strong opinion of the matter use the parent thread group. */ if (g == null) &#123; g = parent.getThreadGroup(); &#125; &#125; this.group = g; this.daemon = parent.isDaemon(); this.priority = parent.getPriority(); this.target = target; setPriority(priority); this.stackSize = stackSize； &#125; 3，如果构造线程对象时未传入ThreadGroup，Thread会默认获取父线程的ThreadGroup作为该线程的ThreadGroup ​ 此时子线程和父线程，将会咋同一个threadGroupzhong 。 4，构造Thread的时候，传入的stackSize代表着该线程占用的栈的大小，如果没有指定stackSize的大小，默认是0，0代表着会忽略该参数，该参数会被JNI去使用，需要注意的是该参数在一些平台有效，在一些平台是没有用的。 -Xss10M 5,t.setDaemon(true): 将线程t设置为守护线程，守护线程就是，当其他线程执行完毕了，只剩下守护线程在运行，那么此时该线程会自动销毁。 常见的场景比如说A——-&gt;B之间进行通信，每隔一段时间A会向B发送一个心跳包，检测B是否有响应，假如B已经结束，那么A就不需要再发送心跳包了，所以可以把A设置成一个守护线程，这样B结束了，A也就结束了。 注意：设置成守护线程也存在着一个问题：假如另一个线程启动，开始进入Running状态，但是此时守护线程还是Runnable状态，并没有进入Running状态，而另一个线程就已经结束了，导致守护线程没来及获得CPU执行权，就已经结束了。 示例代码： 123456789101112131415161718192021222324252627282930package com.primeton.thread.one;public class DaemonThread &#123; public static void main(String[] args) throws InterruptedException &#123; Thread thread = new Thread() &#123; @Override public void run() &#123; Thread innerThread = new Thread() &#123; @Override public void run() &#123; while (true) &#123; try &#123; System.out.println("begin send package"); Thread.sleep(100); System.out.println("end send package"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;; innerThread.setDaemon(true); innerThread.start(); /* innerThread.setDaemon(true);*/ &#125; &#125;; thread.start(); Thread.sleep(1000); &#125;&#125; 运行结果： begin send packageend send packagebegin send package Process finished with exit code 0 结论：从运行结果可以看出子线程在父线程执行完毕之后就销毁了而不是一直执行。 ​ t.setDaemon(true)必须设置到start方法的前面，否则就会报： ​ Exception in thread “Thread-0” java.lang.IllegalThreadStateException at java.lang.Thread.setDaemon(Thread.java:1359) at com.primeton.thread.one.DaemonThread$1.run(DaemonThread.java:24) 6，操作系统中线程可以划分优先级，优先级较高的线程得到的CPU资源较多，也就是CPU优先执行优先级较高的线程对象中的任务。 设置线程的优先级使用setPriority()方法 在java中，线程的优先级分为1-10这10个等级，如果小于1或大于10，抛出throw new IllegalArfumentException() JDK中使用3个常量来预置定义优先级的值。 public final static int MIN_PROORITY = 1; public final static int NORM_PROORITY = 5; public final static int MAX_PROORITY = 10; 7，join方法的使用： join方法是什么？：join方法是直到调用join方法的线程执行完毕，才执行当前线程。 方法参数：join(long time) ​ join() 8，sleep和wait的区别所在： ​ 1，sleep和wait都是让线程进入blocked状态 2，sleep方法执行不释放锁，wait方法执行后释放锁 ​ 3，wait方法依赖于synchronized代码块或同步函数，而sleep方法不依赖 ​ 3，sleep方法是Thread类中的方法，而wait方法是Object中的方法 6、线程同步，锁技术1,使用synchronized同步代码块 2，使用同步函数 3，验证同步函数的锁是this 12345678910111213141516171819202122232425262728293031323334package com.primeton.thread.one;public class ThisLock &#123; public static void main(String[] args) &#123; new Thread()&#123; @Override public void run()&#123; try &#123; method1(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;.start(); new Thread()&#123; @Override public void run()&#123; try &#123; method2(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;.start(); &#125; public static synchronized void method1() throws InterruptedException &#123; System.out.println("method1 start"+Thread.currentThread().getName()); Thread.sleep(2000); &#125; public static synchronized void method2() throws InterruptedException &#123; System.out.println("method2 start"+Thread.currentThread().getName()); Thread.sleep(2000); &#125;&#125; 运行结果： 如果其中一个方法不加synchronized关键字，那么俩个方法几乎同时打印出来，加了synchronized的话method2方法要比method1方法后执行，所以同步函数的锁是this。 4，写一个死锁 1234567891011121314151617181920212223242526272829303132333435363738394041package com.primeton.thread.one;public class DeadLock &#123; public static void main(String[] args) &#123; DeadLockDemo deadLockDemo = new DeadLockDemo(); new Thread()&#123; @Override public void run()&#123; deadLockDemo.method1(); &#125; &#125;.start(); new Thread()&#123; @Override public void run()&#123; deadLockDemo.method2(); &#125; &#125;.start(); &#125;&#125;class DeadLockDemo&#123; Object a = new Object(); Object b = new Object(); public void method1()&#123; synchronized (a)&#123; System.out.println("1a"); synchronized (b)&#123; System.out.println("1b"); &#125; &#125; &#125; public void method2()&#123; synchronized (b)&#123; System.out.println("2b"); synchronized (a)&#123; System.out.println("2a"); &#125; &#125; &#125;&#125; 运行结果： 1a2b 线程还在执行中但是造成了死锁，使用jstack工具查看：Found a deadLock。 结论：由于俩个线程相互争抢ab锁造成的 5， 7、如何优雅的停止线程场景：有三个线程，需要从数据库取得数据，然后保存到文件中，要求必须三个线程全部收集完之后，才执行保存操作 示例： 12345678910111213141516171819202122232425262728293031323334353637383940package com.primeton.thread.one;public class JoinThread &#123; public static void main(String[] args) throws InterruptedException &#123; long startTime = System.currentTimeMillis(); Thread t1 = new Thread(new Target("machine01",5000)); Thread t2 = new Thread(new Target("machine02",10000)); Thread t3 = new Thread(new Target("machine03",15000)); t1.start(); t2.start(); t3.start(); t1.join(); t2.join(); t3.join(); long endTime = System.currentTimeMillis(); System.out.println("start time:"+ startTime); System.out.println("end time:"+ endTime); System.out.println("collect data successfully save data to file..."); &#125;&#125;class Target implements Runnable&#123; String machineName; int spendTime; public Target(String machineName,int spendTime) &#123; this.machineName = machineName; this.spendTime = spendTime; &#125; @Override public void run() &#123; try &#123; System.out.println(machineName+"start collect data from databse"+System.currentTimeMillis()); Thread.sleep(spendTime); System.out.println(machineName+"end collect data from databse"+System.currentTimeMillis()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行结果： machine02start collect data from databse1551159820675machine01start collect data from databse1551159820675machine03start collect data from databse1551159820675machine01end collect data from databse1551159825676machine02end collect data from databse1551159830675machine03end collect data from databse1551159835675start time:1551159820672end time:1551159835675collect data successfully save data to file… 2，如何给应用程序注入钩子程序？ 当某个线程结束，时，有时候我们希望去关闭一些资源或者进行一些别的操作。我们可以给程序加一个钩子程序完成。 1234567891011121314151617181920212223242526272829303132333435package com.primeton.thread.one;public class Hook &#123; public static void main(String[] args) &#123; Runtime.getRuntime().addShutdownHook(new Thread()&#123; @Override public void run()&#123; System.out.println("The Application will be exit"); notifyRelase(); &#125; &#125;); int i = 1; while(true)&#123; try &#123; Thread.sleep(1000); System.out.println("I am working"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; i++; if(i &gt;20)&#123; throw new RuntimeException(); &#125; &#125; &#125; public static void notifyRelase()&#123; System.out.println("notify to the admin..."); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("will relase the resource"); &#125;&#125; 2，如何捕获线程运行期间的异常呢？ 首先，我们要知道，在Java中，线程中的异常是不能抛出到调用该线程的外部方法中捕获的。 为什么不能抛出到外部线程捕获？ ​ 因为线程是独立执行的代码片断，线程的问题应该由线程自己来解决，而不要委托到外部。”基于这样的设计理念， 在Java中， ​ 线程方法的异常都应该在线程代码边界之内（run方法内）进行try catch并处理掉.换句话说，我们不能捕获从线程中逃逸的异常。 怎么进行的限制？ ​ 通过java.lang.Runnable.run()方法声明(因为此方法声明上没有throw exception部分)进行了约束。 如果在线程中抛出了线程会怎么样？ ​ 线程会立即终结。 现在我们可以怎样捕获线程中的异常？ ​ JDK5之后有了一个Thread.UncaughtExceptionHandler 新接口，它允许我们在每一个Thread对象上添加一个异常处理器。Thread.UncaughtExceptionHandler.uncaughtException()方法会在线程因未捕获的异常而面临死亡时被调用。 我们该怎么使用啊？？ ​ 首先定义一个异常处理器然后调用线程的getUnCaunghtException()方法 12345678910111213141516171819202122232425package com.primeton.thread.one;public class Hook &#123; public static void main(String[] args) &#123; Thread t1 = new Thread()&#123; @Override public void run()&#123; try &#123; Thread.sleep(1000); int i = 1/0; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; t1.setUncaughtExceptionHandler(new MyUnchecckedExceptionhandler()); t1.start(); &#125;&#125;class MyUnchecckedExceptionhandler implements Thread.UncaughtExceptionHandler &#123; @Override public void uncaughtException(Thread t, Throwable e) &#123; System.out.println("捕获异常处理方法：" + e); &#125;&#125; 运行结果： 捕获异常处理方法：java.lang.ArithmeticException: / by zero 8、线程间通讯列举俩个需求来做一个Thread API的一个综合应用。 需求一： ​ 一个线程要去数据库读取数据，但是要按规定的时间完成读取，如果该线程在规定的5秒之内没有读取完毕，那么就认为该线程超时，立即终止该线程的执行。 思路：由于这个任务可能超时，所以超时后的处理，我们需要搞。 1，写一个Service类，一个执行任务的方法参数为task，一个是超时中断任务的方法， ​ 我们知道，守护线程的作用是，当他的父线程中断了，该守护线程也就中断了， ​ 所以我们可以把执行任务的线程设置成一个守护线程，然后给这个守护线程外面 ​ 设置一个父线程，这样当超时了，我们只需要去中断他的父线程就好了。 ​ 但是也会存在一个问题就是有可能父线程拿到执行权立马就执行完了，那么守护 ​ 线程还没来得及执行就termate了，所以，还要把执行的子线程也就是守护线程调用 ​ join方法，这样只有等当前守护线程执行完了，父线程才会执行。 以下是示例代码： 任务类和执行类： 12345678910111213141516171819202122package com.primeton.thread.one;public class ReadDataFromDatabaseDependTime &#123; public static void main(String[] args) &#123; ReadDataFromDatabase task = new ReadDataFromDatabase(); DataService dataService = new DataService(); dataService.excute(task); dataService.shutdown(5000); &#125;&#125;class ReadDataFromDatabase extends Thread&#123; @Override public void run()&#123; System.out.println("start read data from database..... "); try &#123; Thread.sleep(10000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233package com.primeton.thread.one;public class DataService &#123; private Thread excuteThread; private static boolean isComplete = false; public void excute(Thread task)&#123; excuteThread = new Thread()&#123; @Override public void run()&#123; Thread sub = new Thread(task); sub.setDaemon(true); sub.start(); try &#123; sub.join(); &#125; catch (InterruptedException e) &#123; &#125; isComplete = true; &#125; &#125;; excuteThread.start(); &#125; public void shutdown(long timeout)&#123; long beginTime = System.currentTimeMillis(); while(!isComplete)&#123; if(System.currentTimeMillis() - beginTime &gt; timeout)&#123; System.out.println("执行任务超时，立即结束任务！！"); excuteThread.interrupt(); break; &#125; &#125; isComplete = false; &#125;&#125; 需求二： 假设现在有10个线程去同一个数据库收集数据，但是我如果这10个线程并发的去执行的话，那么可能CPU会忙于CPU之间的切换，从而性能会大大降低，那么为了解决这么一个问题，现在需要限制访问数据库的线程并发数，规定该并发数不能超过五个线程，当超过五个线程时，其他线程就会进入blocked状态，从而cpu就不会切换，当五个中的几个线程收集完数据了，那么其他线程才能继续工作去收集数据。 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.primeton.thread.one;import java.util.LinkedList;public class CaptureThread2 &#123; public static void main(String[] args) &#123; Concurrent concurrents = new Concurrent(); for (int i = 0; i &lt; 10; i++) &#123; new Thread(concurrents).start(); &#125; &#125;&#125;class Concurrent extends Thread&#123; private LinkedList&lt;LOCK&gt; locks = new LinkedList&lt;&gt;(); private int max = 3; @Override public void run()&#123; /*System.out.println("The Thread ---&gt;"+Thread.currentThread().getName()+" is ready to working");*/ synchronized (locks)&#123; while(locks.size() &gt; max)&#123; try &#123; locks.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println("The Thread ---&gt;"+Thread.currentThread().getName()+"is start working"); locks.addLast(new LOCK()); &#125; try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (locks)&#123; System.out.println("The Thread ---&gt;"+Thread.currentThread().getName()+"is finshed"); locks.removeFirst(); locks.notifyAll(); &#125; &#125;&#125;class LOCK&#123;&#125; 9、线程组详细介绍可以把线程归到某一个线程组中，线程组可以有线程对象，也可以有线程组，组中还可以有线程，这样的组织结构类似树。 线程关联线程组：一级关联 父对象中有子对象，但是并不创建孙子对象， 比如在开发中，为了有效对这些线程进行管理，创建一个线程组，将某些线程加入到线程组中。 123456789101112131415161718192021package com.primeton.thread.one;public class ThreadGroupDemo &#123; public static void main(String[] args) &#123; ThreadGroup group = new ThreadGroup("A"); Thread t1 = new Thread(group,"t1")&#123; @Override public void run()&#123; try &#123; Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; t1.start(); System.out.println(group.activeCount()); System.out.println(group.getName()); System.out.println(group.getParent()); &#125;&#125; 10、线程池原理以及实现一个简单的线程池线程池最基本的： 1，任务队列 2，拒绝策略（抛出异常，直接丢弃，阻塞，临时队列） 3，init(初始大小，也叫min) 4,active（同时活跃的线程数） 5，max(最大线程数) 如果太大，虚拟机栈容易崩溃 线程池：如果调用者在创建线程池时，不传递自定义线程池大小，那就使用默认的。 一个自定义线程池的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118package com.primeton.thread.pool;import java.util.ArrayList;import java.util.LinkedList;import java.util.List;public class SimpleThreadPoolOwn &#123; //调用者传给线程池的处理任务的线程个数。 private final int size; //如果调用者不传size参数，使用默认的线程个数 private final static int DEFAULT_SIZE = 10; //任务队列 private final static LinkedList&lt;Runnable&gt; TASK_QUEUE = new LinkedList&lt;&gt;(); //线程每创建一个名称就会加一 private static volatile int seq = 0; //定义该线程名称的前缀 private final static String THREAD_FREFIX = "SIMPLE_THREAD_POOL-"; //创建线程组，将创建的线程都加入到这个线程组中 private final static ThreadGroup GROUP = new ThreadGroup("POOL_GROUP"); //该集合记录正在执行任务的线程 private final static List&lt;WorkedTask&gt; THREAD_QUEUE = new ArrayList&lt;&gt;(); /** * 无参构造函数，当调用者不传参数时，使用默认的线程池大小 */ public SimpleThreadPoolOwn()&#123; this(DEFAULT_SIZE); &#125; /** * 调用者自定义线程池大小，并初始化线程池。 * @param size */ public SimpleThreadPoolOwn(int size)&#123; this.size = size; init(); &#125; //初始化线程池 private void init()&#123; for (int i = 0; i &lt; size; i++) &#123; createWorkTask(); &#125; &#125; /** * 对外暴露的方法，供调用者使用。传入Runnable任务对象。 * @param runnable */ public void submit(Runnable runnable)&#123; synchronized (TASK_QUEUE)&#123; TASK_QUEUE.addLast(runnable); TASK_QUEUE.notifyAll(); &#125; &#125; private void createWorkTask()&#123; WorkedTask task = new WorkedTask(GROUP,THREAD_FREFIX+(seq++)); task.start(); TASK_QUEUE.add(task); &#125; //使用枚举标记线程池的状态 private enum TaskState&#123; FREE, RUNNING, BLOCKED, DEAD &#125; private static class WorkedTask extends Thread&#123; //刚创建时处于FREE状态 private volatile TaskState taskState = TaskState.FREE; public TaskState getTaskState()&#123; return taskState; &#125; public WorkedTask(ThreadGroup group,String name)&#123; super(group,name); &#125; public void close()&#123; taskState = TaskState.DEAD; &#125; @Override public void run()&#123; OUTER: while(this.taskState != TaskState.DEAD)&#123; Runnable runnable; synchronized (TASK_QUEUE)&#123; while(TASK_QUEUE.isEmpty())&#123; try &#123; taskState = TaskState.BLOCKED; TASK_QUEUE.wait(); &#125; catch (InterruptedException e) &#123; break OUTER; &#125; &#125; runnable = TASK_QUEUE.removeFirst(); &#125; if(runnable!=null)&#123; taskState = TaskState.RUNNING; runnable.run(); taskState = TaskState.FREE; &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; SimpleThreadPoolOwn poolOwn = new SimpleThreadPoolOwn(); for (int i = 0; i &lt; 10; i++) &#123; poolOwn.submit(new Runnable() &#123; @Override public void run() &#123; System.out.println("The runnable be serviced by "+Thread.currentThread()+" start."); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("The runnable be serviced by "+Thread.currentThread()+" completed."); &#125; &#125;); &#125; &#125;&#125; 11、线程异常捕获以及线程堆栈信息详细讲解12、FIFO队列以及多线程环境下的运行13、BoolenLock锁实现14、常用设计模式在多线程环境下的使用15、查缺补漏]]></content>
      <categories>
        <category>java多线程核心技术</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java多线程核心技术七_补充]]></title>
    <url>%2F2019%2F02%2F22%2Fjava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%83-%E8%A1%A5%E5%85%85%2F</url>
    <content type="text"><![CDATA[补充7.1需要掌握的技术点：线程组的使用 如何切换线程的状态 SimpleDataFormat类与多线程的解决办法 如何处理线程的异常 7.2线程的状态：线程对象在不同的运行时期有不同的状态，状态信息就存在于State枚举类中。 线程可以处于以下状态之一；NEW：至今尚未启动的线程处于这种状态 RUNNABLE：政在Java虚拟机中执行的线程处于这种状态 BLOCKED：受到阻塞并等待某个监视器锁的线程处于这种状态 WAITING：无限期的等待另一个线程来执行某一特定操作的线程处于这种状态 TIMED_WAITING：等待另一个线程来执行取决于指定等待时间的操作的线程处于这种状态。 TERMINATED：已经退出的线程处于这种状态。 7.3线程组可以八线程归属到某一个线程组中，线程组中可以有线程对象，也可以有线程组，这样的组织结构类似于树的形式， 线程组的作用是可以批量的管理线程或者线程组，有效的对线程或线程组进行组织。 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.primeton.threadgroup;public class ThreadGroupTest &#123; public static void main(String[] args) &#123; Runnable runnable1 = new Runnable() &#123; @Override public void run() &#123; try&#123; while(!Thread.currentThread().isInterrupted())&#123; System.out.println("ThreadName = "+Thread.currentThread().getName()); Thread.sleep(2000); &#125; &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; &#125; &#125; &#125;; Runnable runnable2 = new Runnable() &#123; @Override public void run() &#123; try&#123; while(!Thread.currentThread().isInterrupted())&#123; System.out.println("ThreadName = "+Thread.currentThread().getName()); Thread.sleep(2000); &#125; &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; &#125; &#125; &#125;; ThreadGroup group = new ThreadGroup("温欣的线程组"); Thread t1 = new Thread(group,runnable1); Thread t2 = new Thread(group,runnable2); t1.start(); t2.start(); System.out.println("当前活跃的线程数："+group.activeCount()); System.out.println("线程组的名称是："+group.getName()); &#125;&#125; 运行结果 当前活跃的线程数：2线程组的名称是：温欣的线程组ThreadName = Thread-0ThreadName = Thread-1ThreadName = Thread-0ThreadName = Thread-1ThreadName = Thread-1 7.4SimpleDateFormat非线程安全这个类主要负责日期的转换和格式化。但在多线程的环境中，使用此类容易造成数据转换及处理的不准确，因为SimpleDateFormat类并不是线程安全的。 ​]]></content>
      <categories>
        <category>java多线程核心技术</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java多线程核心技术六_单例模式与多线程]]></title>
    <url>%2F2019%2F02%2F22%2Fjava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%85%AD-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[单例模式与多线程6.1多线程下单例模式的安全问题解决1234567891011121314151617181920212223242526272829303132333435363738package com.primeton;public class SignalTest &#123; public static void main(String[] args) &#123; Runnable runnable = new Runnable() &#123; @Override public void run() &#123; System.out.println(Signal.getInstance().hashCode()); &#125; &#125;; Thread t1 = new Thread(runnable); t1.start(); Thread t2 = new Thread(runnable); t2.start(); Thread t3 = new Thread(runnable); t3.start(); Thread t4 = new Thread(runnable); t4.start(); Thread t5 = new Thread(runnable); t5.start(); &#125;&#125;class Signal &#123; private volatile static Signal signal; private Signal()&#123; &#125; public static Signal getInstance()&#123; synchronized (Signal.class) &#123; if (signal == null) &#123; signal = new Signal(); return signal; &#125; &#125; return signal; &#125;&#125; 运行结果： 12018417721201841772120184177212018417721201841772 结论： 解决方案有俩种，上面那种是最合适的，第一种解决方案是在直接把getInstance方法设置为同步函数，但是这么做会使效率非常低下，只要一个对象获取了锁，那么其他线程再想要创建对象，只能等这个线程执行完，才能继续获取对象。 第二种就是在关键性的代码使用同步代码块来包裹。（DCL双检查锁机制） 6.2使用静态内部类实现单例模式123456789101112131415161718192021222324252627282930313233package com.primeton;public class SignalTest &#123; public static void main(String[] args) &#123; Runnable runnable = new Runnable() &#123; @Override public void run() &#123; System.out.println(Signal.getInstance().hashCode()); &#125; &#125;; Thread t1 = new Thread(runnable); t1.start(); Thread t2 = new Thread(runnable); t2.start(); Thread t3 = new Thread(runnable); t3.start(); Thread t4 = new Thread(runnable); t4.start(); Thread t5 = new Thread(runnable); t5.start(); &#125;&#125;class Signal &#123; private Signal()&#123; &#125; private static class SignalHandler&#123; private static Signal signal = new Signal(); &#125; public static Signal getInstance()&#123; return SignalHandler.signal; &#125;&#125; 运行结果： 499131126499131126499131126499131126499131126 6.3使用static代码块实现单例模式12345678910111213141516171819202122232425262728293031323334package com.primeton;public class SignalTest &#123; public static void main(String[] args) &#123; Runnable runnable = new Runnable() &#123; @Override public void run() &#123; System.out.println(Signal.getInstance().hashCode()); &#125; &#125;; Thread t1 = new Thread(runnable); t1.start(); Thread t2 = new Thread(runnable); t2.start(); Thread t3 = new Thread(runnable); t3.start(); Thread t4 = new Thread(runnable); t4.start(); Thread t5 = new Thread(runnable); t5.start(); &#125;&#125;class Signal &#123; private static Signal signal = null; private Signal()&#123; &#125; static &#123; signal = new Signal(); &#125; public static Signal getInstance()&#123; return signal; &#125;&#125; 运行结果： 499131126499131126499131126499131126499131126]]></content>
      <categories>
        <category>java多线程核心技术</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java多线程核核心技术五(定时器)]]></title>
    <url>%2F2019%2F02%2F21%2Fjava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A0%B8%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%BA%94-%E5%AE%9A%E6%97%B6%E5%99%A8%2F</url>
    <content type="text"><![CDATA[定时器_Timer5.0需要掌握的技术点：如何实现指定时间执行任务 如何实现按指定周期执行任务 5.1定时器Timer的使用5.1.1方法schedule(TimerTask task,Date time)的测试Timer中允许多个TimerTask任务： 1234567891011121314151617181920212223242526272829303132package com.primeton.timer;import java.util.Calendar;import java.util.Date;import java.util.Timer;import java.util.TimerTask;public class TimerTest &#123; public static void main(String[] args) &#123; System.out.println("当前时间为："+new Date()); Calendar calendar = Calendar.getInstance(); calendar.add(Calendar.SECOND,10); Date date = calendar.getTime(); System.out.println("计划时间为："+date); Calendar calendar1 = Calendar.getInstance(); calendar1.add(Calendar.SECOND,15); Date date1 = calendar1.getTime(); System.out.println("计划时间为："+date1); MyTask task1 = new MyTask(); MyTask task2 = new MyTask(); Timer timer = new Timer(); timer.schedule(task1,date); timer.schedule(task2,date1); &#125;&#125;class MyTask extends TimerTask&#123; @Override public void run() &#123; System.out.println("任务开始执行了，时间为："+new Date()); &#125;&#125; 运行结果： 当前时间为：Thu Feb 21 21:39:15 CST 2019计划时间为：Thu Feb 21 21:39:25 CST 2019计划时间为：Thu Feb 21 21:39:30 CST 2019任务开始执行了，时间为：Thu Feb 21 21:39:25 CST 2019任务开始执行了，时间为：Thu Feb 21 21:39:30 CST 2019 结论：TimerTask是以队列的方式一个一个被顺序性的执行，所以执行的时间有可能和预期的不一样，因为前面的任务有可能消耗的时间长，则后面的任务运行时间也被延后了。比如下面这个例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.primeton.timer;import java.util.Calendar;import java.util.Date;import java.util.Timer;import java.util.TimerTask;public class TimerTest &#123; public static void main(String[] args) &#123; System.out.println("当前时间为："+new Date()); Calendar calendar = Calendar.getInstance(); calendar.add(Calendar.SECOND,10); Date date = calendar.getTime(); System.out.println("计划时间为："+date); Calendar calendar1 = Calendar.getInstance(); calendar1.add(Calendar.SECOND,15); Date date1 = calendar1.getTime(); System.out.println("计划时间为："+date1); MyTaskA taskA = new MyTaskA(); MyTaskB taskB = new MyTaskB(); Timer timer = new Timer(); timer.schedule(taskA,date); timer.schedule(taskB,date1); &#125;&#125;class MyTaskA extends TimerTask&#123; @Override public void run() &#123; System.out.println("A任务开始执行了，时间为："+new Date()); try &#123; Thread.sleep(10000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("A任务结束执行了，时间为："+new Date()); &#125;&#125;class MyTaskB extends TimerTask&#123; @Override public void run() &#123; System.out.println("B任务开始执行了，时间为："+new Date()); System.out.println("B任务结束执行了，时间为："+new Date()); &#125;&#125; 当前时间为：Thu Feb 21 21:45:47 CST 2019计划时间为：Thu Feb 21 21:45:57 CST 2019计划时间为：Thu Feb 21 21:46:02 CST 2019A任务开始执行了，时间为：Thu Feb 21 21:45:57 CST 2019A任务结束执行了，时间为：Thu Feb 21 21:46:07 CST 2019B任务开始执行了，时间为：Thu Feb 21 21:46:07 CST 2019B任务结束执行了，时间为：Thu Feb 21 21:46:07 CST 2019 5.1.2方法schedult(TimerTask task,Date firstTime,long period)的测试12345678910111213141516171819202122232425262728package com.primeton.timer;import java.util.Calendar;import java.util.Date;import java.util.Timer;import java.util.TimerTask;public class TimerTest &#123; public static void main(String[] args) &#123; System.out.println("当前时间为："+new Date()); Calendar calendar = Calendar.getInstance(); calendar.add(Calendar.SECOND,10); Date date = calendar.getTime(); System.out.println("计划时间为："+date); MyTask task = new MyTask(); Timer timer = new Timer(); timer.schedule(task,date,4000); &#125;&#125;class MyTask extends TimerTask&#123; @Override public void run() &#123; System.out.println("任务开始执行了，时间为："+new Date()); &#125;&#125; 运行结果： 当前时间为：Thu Feb 21 22:33:20 CST 2019计划时间为：Thu Feb 21 22:33:30 CST 2019任务开始执行了，时间为：Thu Feb 21 22:33:30 CST 2019任务开始执行了，时间为：Thu Feb 21 22:33:34 CST 2019任务开始执行了，时间为：Thu Feb 21 22:33:38 CST 2019任务开始执行了，时间为：Thu Feb 21 22:33:42 CST 2019任务开始执行了，时间为：Thu Feb 21 22:33:46 CST 2019 结论：周期性的每四秒执行一次。 5.1.3TimerTask类中的cancel方法TimerTask类中的cancel方法的作用：将自身从任务队列中除去。 1234567891011121314151617181920212223242526272829303132333435363738package com.primeton.timer;import java.util.Calendar;import java.util.Date;import java.util.Timer;import java.util.TimerTask;public class TimerTest &#123; public static void main(String[] args) &#123; System.out.println("当前时间为："+new Date()); Calendar calendar = Calendar.getInstance(); calendar.add(Calendar.SECOND,10); Date date = calendar.getTime(); System.out.println("计划时间为："+date); MyTaskA task = new MyTaskA(); MyTaskB task1 = new MyTaskB(); Timer timer = new Timer(); timer.schedule(task,date,2000); timer.schedule(task1,date,2000); &#125;&#125;class MyTaskA extends TimerTask&#123; @Override public void run() &#123; System.out.println("A任务开始执行了，时间为："+new Date()); this.cancel(); System.out.println("任务自己把自己移除了"); &#125;&#125;class MyTaskB extends TimerTask&#123; @Override public void run() &#123; System.out.println("B任务开始执行了，时间为："+new Date()); &#125;&#125; 运行结果： 当前时间为：Thu Feb 21 22:40:53 CST 2019计划时间为：Thu Feb 21 22:41:03 CST 2019A任务开始执行了，时间为：Thu Feb 21 22:41:03 CST 2019任务自己把自己移除了B任务开始执行了，时间为：Thu Feb 21 22:41:03 CST 2019B任务开始执行了，时间为：Thu Feb 21 22:41:05 CST 2019B任务开始执行了，时间为：Thu Feb 21 22:41:07 CST 2019B任务开始执行了，时间为：Thu Feb 21 22:41:09 CST 2019 结论：TimerTask类中的cancel方法时将自身从任务队列中被移除，其他任务不受影响。 5.14Timer中cancel方法作用：将任务队列中的全部任务进行清空。 1234567891011121314151617181920212223242526272829303132333435363738package com.primeton.timer;import java.util.Calendar;import java.util.Date;import java.util.Timer;import java.util.TimerTask;public class TimerTest &#123; public static void main(String[] args) throws InterruptedException &#123; System.out.println("当前时间为："+new Date()); Calendar calendar = Calendar.getInstance(); calendar.add(Calendar.SECOND,10); Date date = calendar.getTime(); System.out.println("计划时间为："+date); MyTaskA task = new MyTaskA(); MyTaskB task1 = new MyTaskB(); Timer timer = new Timer(); timer.schedule(task,date,2000); timer.schedule(task1,date,2000); Thread.sleep(20000); timer.cancel(); &#125;&#125;class MyTaskA extends TimerTask&#123; @Override public void run() &#123; System.out.println("A任务开始执行了，时间为："+new Date()); &#125;&#125;class MyTaskB extends TimerTask&#123; @Override public void run() &#123; System.out.println("B任务开始执行了，时间为："+new Date()); &#125;&#125; 运行结果： 当前时间为：Thu Feb 21 22:48:20 CST 2019计划时间为：Thu Feb 21 22:48:30 CST 2019A任务开始执行了，时间为：Thu Feb 21 22:48:30 CST 2019B任务开始执行了，时间为：Thu Feb 21 22:48:30 CST 2019B任务开始执行了，时间为：Thu Feb 21 22:48:32 CST 2019A任务开始执行了，时间为：Thu Feb 21 22:48:32 CST 2019A任务开始执行了，时间为：Thu Feb 21 22:48:34 CST 2019B任务开始执行了，时间为：Thu Feb 21 22:48:34 CST 2019B任务开始执行了，时间为：Thu Feb 21 22:48:36 CST 2019A任务开始执行了，时间为：Thu Feb 21 22:48:36 CST 2019 结论：所有的任务都被销毁了。 注意事项： ​ Timer类中的cancel方法有时并不一定会停止计划任务，而是正常执行。 ​ 12345678910111213141516171819202122232425262728293031package com.primeton.timer;import java.util.Calendar;import java.util.Date;import java.util.Timer;import java.util.TimerTask;public class ZhuYI &#123; public static void main(String[] args) &#123; int i = 0; while(true)&#123; i++; Calendar calendar = Calendar.getInstance(); Date date = calendar.getTime(); MyTask task = new MyTask(i); Timer timer = new Timer(); timer.schedule(task,date); timer.cancel(); &#125; &#125;&#125;class MyTask extends TimerTask&#123; int i; MyTask(int i)&#123; this.i = i; &#125; @Override public void run() &#123; System.out.println("任务的第 "+i+" 次没有被cancel取消"); &#125;&#125; 运行结果： 任务的第 10624 次没有被cancel取消 结论：原因是cancel方法没有抢到queue锁，则让TimerTask类中的任务正常执行了。 5.15方法schedule(TimerTask task，long delay)作用：该方法的作用是以执行schedule方法当前的时间为参考时间，在此时间延迟指定的毫秒数后执行一次TimerTask任务 12345678910111213141516171819202122package com.primeton.timer;import java.util.Calendar;import java.util.Date;import java.util.Timer;import java.util.TimerTask;public class ZhuYI &#123; public static void main(String[] args) &#123; System.out.println("dangqian time:"+new Date()); MyTask task = new MyTask(); Timer timer = new Timer(); timer.schedule(task,2000); &#125;&#125;class MyTask extends TimerTask&#123; @Override public void run() &#123; System.out.println("任务开始执行了时间为："+new Date()); &#125;&#125; 运行结果： dangqian time:Thu Feb 21 23:22:40 CST 2019任务开始执行了时间为：Thu Feb 21 23:22:42 CST 2019 任务task被延迟了俩秒执行。 5.16方法schedule(TimerTask task，long delay，long period)作用：该方法的作用是以执行schedule方法当前的时间为参考时间，在此时间延迟指定的毫秒数后执行一次TimerTask任务,再以指定的时间周期执行这个任务。 12345678910111213141516171819202122package com.primeton.timer;import java.util.Calendar;import java.util.Date;import java.util.Timer;import java.util.TimerTask;public class ZhuYI &#123; public static void main(String[] args) &#123; System.out.println("dangqian time:"+new Date()); MyTask task = new MyTask(); Timer timer = new Timer(); timer.schedule(task,2000,1000); &#125;&#125;class MyTask extends TimerTask&#123; @Override public void run() &#123; System.out.println("任务开始执行了时间为："+new Date()); &#125;&#125; 运行结果： dangqian time:Thu Feb 21 23:24:39 CST 2019任务开始执行了时间为：Thu Feb 21 23:24:41 CST 2019任务开始执行了时间为：Thu Feb 21 23:24:42 CST 2019任务开始执行了时间为：Thu Feb 21 23:24:43 CST 2019任务开始执行了时间为：Thu Feb 21 23:24:44 CST 2019 5.17方法scheduleAtFixedRate(TimerTask task,Date firstTime,long period)的测试。方法schedule和scheduleAtFixedRate都会按顺序执行，他们之间的区别就是：在于有没有追赶特性。 如果计划执行时间早于当前时间，那么schedulr方法执行的任务不具备追赶性，也就是说，从计划之间到当前时间的任务都会被取消，而scheduleAtFixedRate方法具有追赶性，也就是计划时间到当前时间的任务，被补充性的执行了。 总结：定时器Timer更多的应用在了andriod技术中，比如实现类似于轮询，动画等常见的功能。]]></content>
      <categories>
        <category>java多线程核心技术</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程核心技术(四)]]></title>
    <url>%2F2019%2F02%2F21%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[Lock的使用4.1使用ReentrantLock类4.1.1使用ReentrantLock实现同步： 在java多线程中可以使用synchronized关键字和同步代码块来实现线程之间同步互斥，但在JDK1.5中新增了ReentrantLock类也能达到同样的效果。并且在扩展上更加强大。比如具有嗅探锁定，多路分支通知等功能。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.primeton.lock;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class ReentrantLockTest &#123; public static void main(String[] args) &#123; Resource resource = new Resource(); Thread1 thread1 = new Thread1(resource); thread1.start(); Thread1 thread2 = new Thread1(resource); thread2.start(); Thread1 thread3 = new Thread1(resource); thread3.start(); &#125;&#125;class Resource&#123; private Lock lock = new ReentrantLock(); public void method()&#123; lock.lock(); for (int i = 0; i &lt; 5; i++) &#123; System.out.println("ThreadName="+Thread.currentThread().getName()+(" "+(i+1))); &#125; lock.unlock(); &#125;&#125;class Thread1 extends Thread&#123; private Resource resource; Thread1(Resource resource)&#123; this.resource = resource; &#125; @Override public void run()&#123; resource.method(); &#125;&#125;class Thread2 extends Thread&#123; private Resource resource; Thread2(Resource resource)&#123; this.resource = resource; &#125; @Override public void run()&#123; resource.method(); &#125;&#125; 结论：调用ReentrantLock对象的lock方法获取锁，调用unlock方法释放锁。 4.1.2修改多生产者多消费者代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package com.primeton.lock;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class ProducerLock&#123; public static void main(String[] args) &#123; Resour resour = new Resour(); Producer producer1 = new Producer(resour); producer1.start(); Producer producer2 = new Producer(resour); producer2.start(); Customer customer1 = new Customer(resour); customer1.start(); Customer customer2 = new Customer(resour); customer2.start(); &#125;&#125;class Resour&#123; private String name; private int count = 1; private boolean flag = false; private Lock lock = new ReentrantLock(); Condition producer_con = lock.newCondition(); Condition customer_com = lock.newCondition(); public void produce(String name) throws InterruptedException &#123; lock.lock(); while(flag)&#123; producer_con.await(); &#125; this.name = name + count; Thread.sleep(100); System.out.println(Thread.currentThread().getName()+"...生产者..."+this.name); count++; flag = true; customer_com.signal(); lock.unlock(); &#125; public void customer() throws InterruptedException &#123; lock.lock(); while(!flag)&#123; customer_com.await(); &#125; Thread.sleep(100); System.out.println(Thread.currentThread().getName()+"...消费者........."+this.name); flag = false; producer_con.signal(); lock.unlock(); &#125;&#125;class Producer extends Thread&#123; private Resour r ; Producer(Resour r)&#123; this.r = r; &#125; @Override public void run()&#123; while (true)&#123; try &#123; r.produce("烤鸭"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;class Customer extends Thread&#123; private Resour r ; Customer(Resour r)&#123; this.r = r; &#125; @Override public void run()&#123; while (true)&#123; try &#123; r.customer(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 结论： 使用ReentrantLock代替了之前的synchronized同步函数，使用Condition代替了之前的Object中的wait/notify方法。 4.1.3公平锁和非公平锁公平锁：加锁前检查是否有排队等待的线程，优先排队等待的线程先来先得的FIFO先进先出的顺序。 非公平锁：加锁时不考虑排队等待的问题，直接尝试获取锁获取不到自动到队尾等待 如何设置公平锁和非公平锁： 源码： 1public ReentrantLock(boolean fair) &#123; sync = fair ? new FairSync() : new NonfairSync();&#125; 123public ReentrantLock() &#123; sync = new NonfairSync();&#125; 由源码可以知道ReentrantLock无参时为默认的非公平锁，传入参数true时，为公平锁。 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.primeton.lock;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class IsFair &#123; public static void main(String[] args) &#123; Service service = new Service(false); ThreadA target = new ThreadA(service); Thread[] thread = new Thread[10]; for (int i = 0; i &lt; 10; i++) &#123; thread[i] = new Thread(target); &#125; for (int i = 0; i &lt; 10; i++) &#123; thread[i].start(); &#125; &#125;&#125;class Service&#123; private Lock lock; Service(boolean isFair)&#123; lock = new ReentrantLock(isFair); &#125; public void method()&#123; try&#123; lock.lock(); System.out.println("ThreadName = "+Thread.currentThread().getName()+"获得了锁"); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; lock.unlock(); &#125; &#125;&#125;class ThreadA implements Runnable&#123; private Service service; ThreadA(Service service)&#123; this.service = service; &#125; @Override public void run() &#123; service.method(); &#125;&#125; 通过改变isFair的值改变公平锁和非公平锁。 当isFair为true时，说明是公平锁 hreadName = Thread-0获得了锁ThreadName = Thread-1获得了锁ThreadName = Thread-2获得了锁ThreadName = Thread-3获得了锁ThreadName = Thread-4获得了锁ThreadName = Thread-5获得了锁ThreadName = Thread-6获得了锁ThreadName = Thread-8获得了锁ThreadName = Thread-9获得了锁ThreadName = Thread-7获得了锁 打印的结果基本上时按线程启动的顺序来获取锁的 当isFair为false时，说明是非公平锁 ThreadName = Thread-0获得了锁ThreadName = Thread-1获得了锁ThreadName = Thread-3获得了锁ThreadName = Thread-4获得了锁ThreadName = Thread-5获得了锁ThreadName = Thread-7获得了锁ThreadName = Thread-9获得了锁ThreadName = Thread-2获得了锁ThreadName = Thread-6获得了锁ThreadName = Thread-8获得了锁 乱序，说明先start启动的线程不代表先获得锁。 4.1.4方法getHoldCount，getQueueLength，和getWaitQueueLength的测试1）方法 int getHoldCount的作用是查询当前线程保持此锁定的个数，也就是调用lock方法的次数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.primeton.lock;import java.util.concurrent.locks.ReentrantLock;public class GetHoldCount &#123; public static void main(String[] args) &#123; Ser ser = new Ser(); Runnable runnable1 = new Runnable()&#123; @Override public void run() &#123; ser.serviceMethod1(); &#125; &#125;; Runnable runnable2 = new Runnable() &#123; @Override public void run() &#123; ser.serviceMethod2(); &#125; &#125;; Thread t1 = new Thread(runnable1); Thread t2 = new Thread(runnable2); t1.start(); t2.start(); &#125;&#125;class Ser &#123; private ReentrantLock lock = new ReentrantLock(); public void serviceMethod1()&#123; try&#123; lock.lock(); System.out.println(Thread.currentThread().getName()+"serviceMethod1 getHoldCount="+lock.getHoldCount()); serviceMethod2(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; lock.unlock(); &#125; &#125; public void serviceMethod2()&#123; try&#123; lock.lock(); System.out.println(Thread.currentThread().getName()+"serviceMethod2 getHoldCount="+lock.getHoldCount()); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; lock.unlock(); &#125; &#125;&#125; 运行结果： Thread-0serviceMethod1 getHoldCount=1Thread-0serviceMethod2 getHoldCount=2Thread-1serviceMethod2 getHoldCount=1 2）方法 int getQueueLength()的作用是返回正在等待获取此锁的线程的估计数。 比如：有五个线程，1个线程首先执行了await方法，那么在调用getQueueLength方法后返回的值是4，说明有4个线程同时在等待llock锁的释放。 123456789101112131415161718192021222324252627282930313233343536373839package com.primeton.lock;import java.util.concurrent.locks.ReentrantLock;public class GetQueueLength &#123; public static void main(String[] args) throws InterruptedException &#123; Ser2 ser2 = new Ser2(); Runnable runnable = new Runnable() &#123; @Override public void run() &#123; ser2.method1(); &#125; &#125;; Thread[] threads = new Thread[10]; for (int i = 0; i &lt; 10; i++) &#123; threads[i] = new Thread(runnable); &#125; for (int i = 0; i &lt; 10; i++) &#123; threads[i].start(); &#125; Thread.sleep(2000); System.out.println("当前等待的线程数是："+ser2.lock.getQueueLength()); &#125;&#125;class Ser2&#123; public ReentrantLock lock = new ReentrantLock(); public void method1()&#123; try&#123; lock.lock(); System.out.println("TheadName= " + Thread.currentThread().getName()+"进入方法"); Thread.sleep(Integer.MAX_VALUE); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; lock.unlock(); &#125; &#125;&#125; 运行结果： TheadName= Thread-0进入方法当前等待的线程数是：9 3） int getWaitQueueLength() 的作用是返回等待与此锁相关的给定条件Condition的线程估计数。 比如有五个线程，每个线程都执行了同一个Condition对象的await方法，则调用getWaitQueueLength方法返回的值就是五了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.primeton.lock;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.ReentrantLock;public class GetQueueLength &#123; public static void main(String[] args) throws InterruptedException &#123; Ser2 ser2 = new Ser2(); Runnable runnable = new Runnable() &#123; @Override public void run() &#123; ser2.method1(); &#125; &#125;; Thread[] threads = new Thread[10]; for (int i = 0; i &lt; 10; i++) &#123; threads[i] = new Thread(runnable); &#125; for (int i = 0; i &lt; 10; i++) &#123; threads[i].start(); &#125; Thread.sleep(2000); ser2.method2(); &#125;&#125;class Ser2&#123; public ReentrantLock lock = new ReentrantLock(); Condition condition = lock.newCondition(); public void method1()&#123; try&#123; lock.lock(); condition.await(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; lock.unlock(); &#125; &#125; public void method2()&#123; try&#123; lock.lock(); System.out.println("当前正在等待的线程数是："+lock.getWaitQueueLength(condition)); condition.signal(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; lock.unlock(); &#125; &#125;&#125; 运行结果： 当前正在等待的线程数是：10 4.1.5 方法hasQueuedTrhead(),hasQueuedThreads(),hasWaiters()测试1）方法 boolean hasQueuedThread(Thread thread) 的作用是查询指定的线程是否正在等待获取这个锁。 2）方法 boolean hasQueuedThread(sThread thread) 的作用是 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.primeton.lock;import java.util.concurrent.locks.ReentrantLock;public class GetQueueLength &#123; public static void main(String[] args) throws InterruptedException &#123; Ser2 ser2 = new Ser2(); Runnable runnable = new Runnable() &#123; @Override public void run() &#123; ser2.method1(); &#125; &#125;; Thread t1 = new Thread(runnable); Thread t2 = new Thread(runnable); t1.start(); Thread.sleep(500); t2.start(); Thread.sleep(500); System.out.println(ser2.lock.hasQueuedThread(t1)); System.out.println(ser2.lock.hasQueuedThread(t2)); System.out.println(ser2.lock.hasQueuedThreads()); /* Thread[] threads = new Thread[10]; for (int i = 0; i &lt; 10; i++) &#123; threads[i] = new Thread(runnable); &#125; for (int i = 0; i &lt; 10; i++) &#123; threads[i].start(); &#125;*/ /*Thread.sleep(2000);*/ /*ser2.method2();*/ &#125;&#125;class Ser2&#123; public ReentrantLock lock = new ReentrantLock(); /*Condition condition = lock.newCondition();*//**/ public void method1()&#123; try&#123; lock.lock(); Thread.sleep(Integer.MAX_VALUE); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; lock.unlock(); &#125; &#125; /* public void method2()&#123; try&#123; lock.lock(); System.out.println("当前正在等待的线程数是："+lock.getWaitQueueLength(condition)); condition.signal(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; lock.unlock(); &#125; &#125;*/&#125; 3)方法boolean hasWaiters(Condition condition)的作用是查询是否有线程正在等待与此锁有关的condition条件。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.primeton.lock;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.ReentrantLock;public class GetQueueLength &#123; public static void main(String[] args) throws InterruptedException &#123; Ser2 ser2 = new Ser2(); Runnable runnable = new Runnable() &#123; @Override public void run() &#123; ser2.method1(); &#125; &#125;; Thread[] threads = new Thread[10]; for (int i = 0; i &lt; 10; i++) &#123; threads[i] = new Thread(runnable); &#125; for (int i = 0; i &lt; 10; i++) &#123; threads[i].start(); &#125; Thread.sleep(2000); ser2.method2(); &#125;&#125;class Ser2&#123; public ReentrantLock lock = new ReentrantLock(); Condition condition = lock.newCondition(); public void method1()&#123; try&#123; lock.lock(); condition.await(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; lock.unlock(); &#125; &#125; public void method2()&#123; try&#123; lock.lock(); System.out.println("是否有线程正在等待newCondition?"+lock.hasWaiters(condition)+"线程数是；"+lock.getWaitQueueLength(condition)); condition.signal(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; lock.unlock(); &#125; &#125;&#125; 运行结果： 是否有线程正在等待newCondition?true线程数是；10 4.1.5方法 isFair()，isHeldByCurrentThread(),isLocked()测试1）方法 boolean isFair()的作用是判断是不是公平锁 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.primeton.lock;import java.util.concurrent.locks.ReentrantLock;public class IsFair &#123; public static void main(String[] args) &#123; Service service = new Service(false); ThreadA target = new ThreadA(service); Thread[] thread = new Thread[10]; for (int i = 0; i &lt; 10; i++) &#123; thread[i] = new Thread(target); &#125; for (int i = 0; i &lt; 10; i++) &#123; thread[i].start(); &#125; &#125;&#125;class Service&#123; private ReentrantLock lock; Service(boolean isFair)&#123; lock = new ReentrantLock(isFair); &#125; public void method()&#123; try&#123; lock.lock(); /* System.out.println("ThreadName = "+Thread.currentThread().getName()+"获得了锁");*/ System.out.println("公平锁的情况："+lock.isFair()); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; lock.unlock(); &#125; &#125;&#125;class ThreadA implements Runnable&#123; private Service service; ThreadA(Service service)&#123; this.service = service; &#125; @Override public void run() &#123; service.method(); &#125;&#125; 运行结果： 公平锁的情况：false 。。。 把参数改成true，运行结果就是true了。 2）方法boolean isHeldByCurrentThread() 作用是查询当前线程是否持有锁。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.primeton.lock;import java.util.concurrent.locks.ReentrantLock;public class IsFair &#123; public static void main(String[] args) &#123; Service service = new Service(false); ThreadA target = new ThreadA(service); /*Thread[] thread = new Thread[10]; for (int i = 0; i &lt; 10; i++) &#123; thread[i] = new Thread(target); &#125; for (int i = 0; i &lt; 10; i++) &#123; thread[i].start(); &#125;*/ Thread thread = new Thread(target); thread.start(); &#125;&#125;class Service&#123; private ReentrantLock lock; Service(boolean isFair)&#123; lock = new ReentrantLock(isFair); &#125; public void method()&#123; try&#123; System.out.println("判断当前线程是否持有锁"+lock.isHeldByCurrentThread()); lock.lock(); System.out.println("判断当前线程是否持有锁"+lock.isHeldByCurrentThread()); /* System.out.println("ThreadName = "+Thread.currentThread().getName()+"获得了锁");*/ System.out.println("公平锁的情况："+lock.isFair()); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; lock.unlock(); &#125; &#125;&#125;class ThreadA implements Runnable&#123; private Service service; ThreadA(Service service)&#123; this.service = service; &#125; @Override public void run() &#123; service.method(); &#125;&#125; 运行结果； 判断当前线程是否持有锁false判断当前线程是否持有锁true 3）方法 boolean isLocked()方法的作用是查询此锁是否由任意线程保持。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.primeton.lock;import java.util.concurrent.locks.ReentrantLock;public class IsFair &#123; public static void main(String[] args) &#123; Service service = new Service(false); ThreadA target = new ThreadA(service); /*Thread[] thread = new Thread[10]; for (int i = 0; i &lt; 10; i++) &#123; thread[i] = new Thread(target); &#125; for (int i = 0; i &lt; 10; i++) &#123; thread[i].start(); &#125;*/ Thread thread = new Thread(target); thread.start(); &#125;&#125;class Service&#123; private ReentrantLock lock; Service(boolean isFair)&#123; lock = new ReentrantLock(isFair); &#125; public void method()&#123; try&#123; System.out.println("判断这个锁是否由任意线程持有"+lock.isLocked()); /* System.out.println("判断当前线程是否持有锁"+lock.isHeldByCurrentThread());*/ lock.lock(); System.out.println("判断这个锁是否由任意线程持有"+lock.isLocked()); /* System.out.println("ThreadName = "+Thread.currentThread().getName()+"获得了锁");*/ /*System.out.println("公平锁的情况："+lock.isFair());*/ &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; lock.unlock(); &#125; &#125;&#125;class ThreadA implements Runnable&#123; private Service service; ThreadA(Service service)&#123; this.service = service; &#125; @Override public void run() &#123; service.method(); &#125;&#125; 运行结果： 判断这个锁是否由任意线程持有false判断这个锁是否由任意线程持有true 4.1.6方法lockInterruptibly，tryLock(),tryLock(long timeout,TimeUtil unit)测试1）方法lockinterruptibly的作用是如果当前线程未被中断，则获取锁，如果已经中断则抛出异常 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.primeton.lock;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.ReentrantLock;public class LockInterruptibly &#123; public static void main(String[] args) throws InterruptedException &#123; Serv3 serv3 = new Serv3(); Runnable runnable = new Runnable() &#123; @Override public void run() &#123; serv3.method(); &#125; &#125;; Thread t1 = new Thread(runnable,"A"); Thread t2 = new Thread(runnable,"B"); t1.start(); Thread.sleep(200); t2.start(); t2.interrupt(); System.out.println("main end"); &#125;&#125;class Serv3&#123; private ReentrantLock lock = new ReentrantLock(); private Condition condition = lock.newCondition(); public void method()&#123; try&#123; lock.lockInterruptibly(); System.out.println("lock begin" + Thread.currentThread().getName()); for (int i = 0; i &lt; Integer.MAX_VALUE / 10; i++) &#123; String s = new String(); &#125; System.out.println("lock begin" + Thread.currentThread().getName()); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; if(lock.isHeldByCurrentThread())&#123; lock.unlock(); &#125; &#125; &#125;&#125; 运行结果： lock beginAlock beginAmain endjava.lang.InterruptedException at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly(AbstractQueuedSynchronizer.java:1220) at java.util.concurrent.locks.ReentrantLock.lockInterruptibly(ReentrantLock.java:335) at com.primeton.lock.Serv3.method(LockInterruptibly.java:29) at com.primeton.lock.LockInterruptibly1.run(LockInterruptibly.java:12) at java.lang.Thread.run(Thread.java:748) 2）tryLock()的作用是，仅在调用时锁未被另一个线程保持的情况下，才获取该锁。 3）boolean tryLock(longtime,TimeUnit unit)的作用是如果锁在给定的等待时间内没有被另一个线程保持，且当前线程没有被中断，则获取该锁。 4.1.7方法awaitUninterruptibly的使用1234567891011121314151617181920212223242526272829303132333435363738package com.primeton.lock;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.ReentrantLock;public class AwaitUninterruptibly &#123; public static void main(String[] args) throws InterruptedException &#123; Serv4 serv4 = new Serv4(); Runnable runnable =new Runnable() &#123; @Override public void run() &#123; serv4.method(); &#125; &#125;; Thread t1 = new Thread(runnable); t1.start(); Thread.sleep(200); t1.interrupt(); &#125;&#125;class Serv4&#123; ReentrantLock lock = new ReentrantLock(); Condition condition = lock.newCondition(); public void method()&#123; try&#123; lock.lock(); System.out.println("wait begin"); condition.awaitUninterruptibly(); System.out.println("wait end"); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; lock.unlock(); &#125; &#125;&#125; 运行结果： wait begin 不会抛出异常，如果改为condition.await()就会抛出异常了。 4.1.8方法awaitUntil的使用1234567891011121314151617181920212223242526272829303132333435package com.primeton.lock;import java.util.Calendar;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.ReentrantLock;public class AwaitUntil &#123; public static void main(String[] args) &#123; Serv5 ser5 = new Serv5(); Runnable runnable = new Runnable() &#123; @Override public void run() &#123; try &#123; ser5.method(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; Thread t1 = new Thread(runnable); t1.start(); &#125;&#125;class Serv5&#123; ReentrantLock lock = new ReentrantLock(); Condition condition = lock.newCondition(); public void method() throws InterruptedException &#123; Calendar calendar = Calendar.getInstance(); calendar.add(Calendar.SECOND,10); lock.lock(); System.out.println("wait begin..."); condition.awaitUntil(calendar.getTime()); System.out.println("wait end"); &#125;&#125; 结论：等待十秒之后自动进行唤醒。 4.2使用ReentrantReadWriteLock在某些不需要操作实例变量的方中，完全可以使用读写锁ReentrantReadWriteLock来提升方法的代码运行速度。 读写锁表示也有俩个锁，一个是读操作相关的锁，也成为共享锁，另一个是写操作相关的锁，也叫排他锁，也就 是多个读锁之间不互斥，读锁与写锁互斥，写锁与写锁互斥，在没有线程，进行写入操作的时候，进行读取操作的 多个线程，都可以获取读锁，而进行写入操作的Thread只有在获取写锁之后才能进行写入操作，即多个线程可以同时 进行读取操作，但是同一时刻，只允许一个线程进行写入操作。 4.2.1使用：读读共享1234567891011121314151617181920212223242526272829303132package com.primeton.lock; import java.util.concurrent.locks.ReentrantReadWriteLock;public class ReetrantReadWriteLockTest &#123; public static void main(String[] args) &#123; Serv6 serv6 = new Serv6(); Runnable runnable = new Runnable() &#123; @Override public void run() &#123; serv6.read(); &#125; &#125;; Thread t1 = new Thread(runnable); Thread t2 = new Thread(runnable); t1.start(); t2.start(); &#125;&#125;class Serv6&#123; ReentrantReadWriteLock lock = new ReentrantReadWriteLock(); public void read()&#123; try&#123; lock.readLock().lock(); System.out.println("ThreadName = " +Thread.currentThread().getName()+"获得了读锁"+System.currentTimeMillis()); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; lock.readLock().lock(); &#125; &#125;&#125; 运行结果： ThreadName = Thread-0获得了读锁1550751235314ThreadName = Thread-1获得了读锁1550751235315 结论： 从控制台打印的运结果来看，来个线程几乎是同时进入lock方法后面的代码，说明在使用lock.readLock()读锁可以提高运行效率，允许多个线程同时执行lock（）方法后面的代码 4.2.2写写互斥123456789101112131415161718192021222324252627282930313233package com.primeton.lock; import java.util.concurrent.locks.ReentrantReadWriteLock;public class ReetrantReadWriteLockTest &#123; public static void main(String[] args) &#123; Serv6 serv6 = new Serv6(); Runnable runnable = new Runnable() &#123; @Override public void run() &#123; serv6.write(); &#125; &#125;; Thread t1 = new Thread(runnable); Thread t2 = new Thread(runnable); t1.start(); t2.start(); &#125;&#125;class Serv6&#123; ReentrantReadWriteLock lock = new ReentrantReadWriteLock(); public void write()&#123; try&#123; lock.writeLock().lock(); System.out.println("ThreadName = " +Thread.currentThread().getName()+"获得了写锁"+System.currentTimeMillis()); Thread.sleep(10000); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; lock.writeLock().unlock(); &#125; &#125;&#125; 运行结果： ThreadName = Thread-0获得了写锁1550751915637ThreadName = Thread-1获得了写锁1550751925639 结论： 证明了 ，写锁，在同一时间，只允许一个线程执行lock后面的代码 4.2.3读写互斥123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.primeton.lock;import java.util.concurrent.locks.ReentrantReadWriteLock;public class ReetrantReadWriteLockTest &#123; public static void main(String[] args) throws InterruptedException &#123; Serv6 serv6 = new Serv6(); Runnable runnable1 = new Runnable() &#123; @Override public void run() &#123; serv6.read(); &#125; &#125;; Runnable runnable2 = new Runnable() &#123; @Override public void run() &#123; serv6.write(); &#125; &#125;; Thread t1 = new Thread(runnable1); Thread t2 = new Thread(runnable2); t1.start(); Thread.sleep(1000); t2.start(); &#125;&#125;class Serv6&#123; ReentrantReadWriteLock lock = new ReentrantReadWriteLock(); public void read()&#123; try&#123; lock.readLock().lock(); System.out.println("ThreadName = " +Thread.currentThread().getName()+"获得了读锁"+System.currentTimeMillis()); Thread.sleep(10000); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; lock.readLock().unlock(); &#125; &#125; public void write()&#123; try&#123; lock.writeLock().lock(); System.out.println("ThreadName = " +Thread.currentThread().getName()+"获得了写锁"+System.currentTimeMillis()); Thread.sleep(10000); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; lock.writeLock().unlock(); &#125; &#125;&#125; 运行结果： ThreadName = Thread-0获得了读锁1550753188015ThreadName = Thread-1获得了写锁1550753198016 结论：从运行结果上看获取了读锁在同一时间就不能获取写锁了，所以读写是互斥的。 同理写读也是互斥的 总结：读写，写写，写读都是互斥的，而读读是异步的，非互斥的。]]></content>
      <categories>
        <category>java多线程核心技术</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程编程核心技术(三)]]></title>
    <url>%2F2019%2F02%2F18%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[线程之间的通信线程时操作系统中独立的个体，但这些个体如果不经过特殊的处理就不能成为一个整体，线程间的通信就是成为整体的核心，使线程进行通信后，系统之间的交互性会更强大，在大大提高CPU利用率的同事，还会使程序员对各线程任务在处理的过程中进行有效的把控与监督。 3.1技术点：​ 1，使用wait/notify实现线程之间的通信 ​ 2，生产者/消费者的实现 ​ 3，方法join的使用 ​ 4，ThreadLocal类的使用 3.2等待通知机制一句话：wait和notify： ​ wait使线程停止运行 ​ notify使线程继续运行 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.primeton.tongxin;import java.util.ArrayList;public class MyList &#123; private static ArrayList list = new ArrayList(); public static void add()&#123; list.add("any"); &#125; public static int getSize()&#123; return list.size(); &#125;&#125;class ThreadA extends Thread&#123; private Object lock; ThreadA(Object lock)&#123; this.lock = lock; &#125; @Override public void run()&#123; synchronized (lock)&#123; if(MyList.getSize() != 5)&#123; try &#123; System.out.println("begin = "+ System.currentTimeMillis()); lock.wait(); System.out.println("end = "+System.currentTimeMillis()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;class ThreadB extends Thread&#123; private Object lock; ThreadB(Object lock)&#123; this.lock = lock; &#125; @Override public void run()&#123; synchronized (lock)&#123; for (int i = 0; i &lt; 10; i++) &#123; MyList.add(); if(MyList.getSize() == 5)&#123; lock.notify(); System.out.println("已经发出通知"); &#125; System.out.println("添加了第" + (i+1) + "个数"); &#125; &#125; &#125;&#125;class Running&#123; public static void main(String[] args) throws InterruptedException &#123; Object lock = new Object(); ThreadA threadA = new ThreadA(lock); threadA.start(); Thread.sleep(1000); ThreadB threadB = new ThreadB(lock); threadB.start(); &#125;&#125; 运行结果： begin = 1550473581521添加了第1个数添加了第2个数添加了第3个数添加了第4个数已经发出通知添加了第5个数添加了第6个数添加了第7个数添加了第8个数添加了第9个数添加了第10个数end = 1550473582521 结论： ​ 日志信息wait end 在最后输出，这也说明了notify方法在执行后并不立即释放锁。 ​ wait()方法：可以使调用该方法的线程释放共享资源的锁，然后从运行状态退出，进入等待队列，直到再次被唤醒。 ​ notify()方法：可以随机唤醒等待队列中等待同一资源的 一个线程，并使该线程退出等待队列，进入可运行的状态，也就是notify方法只能通知一个线程。 ​ notifyAll方法：可以使所有正在等待队列中等待同一资源的全部线程从等待状态退出，进入可运行状态，此时，优先级最高的那个线程最先执行，但是也有可能是随机执行，因为这取决于JVM虚拟机的实现。 3.3线程状态切换描述：1）新创建一个新的线程兑现后，再调用它的start（）方法，系统会给该线程分配CPU资源，使其处于Runnable（可运行）状态，这个一个准备运行的阶段，如果线程抢占到CPU资源，此线程就处于Running(运行)状态 2）Runnable状态和Running状态可以相互切换，以为有可能线程运行一段时间后，有其他高优先级的线程抢占了CPU资源，这时此线程就从Running状态变成可Runnable状态 线程进入Runnable状态大体分为如下五种情况： ​ 调用sleep方法后经过的时间超过了指定的休眠时间 ​ 线程调用的阻塞IO已经返回，阻塞方法执行完毕 ​ 线程成功的获取了锁对象 ​ 线程正在等待某个通知，其他线程发出了通知 ​ 处于挂起状态的线程调用了resume恢复方法。 3）Blocked是阻塞的意思，例如遇到了一个IO操作，此时CPU处于空闲状态，可能会转而把CPU时间片分配给其他线程，这时也可以称为暂停状态，Blocked状态结束后，进入Runnable状态，等待系统重新分配资源。 出现阻塞的情况： ​ 线程调用sleep方法，主动放弃占有的处理器资源 ​ 线程调用了阻塞式IO方法，在该方法返回前，该线程被阻塞 ​ 线程试图获得锁，但是该锁正在被其他线程持有 ​ 线程正在等待某个通知 ​ 程序调用了suspend方法将该线程挂起，此方法容易导致死锁。不使用。 4）run方法运行结束后进入销毁阶段，整个线程执行完毕。 小结： ​ 每个锁对象都有俩个队列，一个是就绪队列，一个是阻塞队列，就绪队列存储了将要获得锁的线程，阻塞队列存储了被阻塞了的线程，一个线程被唤醒后，才会进入就绪队列，等待CPU调度，相反，一个线程被wait后救护进入注射队列，等待下一次被唤醒。 3.4方法wait()锁释放，与notify()锁不释放。1）执行完同步代码块就会释放对象的锁 2）在执行同步代码块的过程中，遇到异常而导致线程终止，锁也会被释放 3）在执行同步代码块的过程中，执行了锁所属对象的wait方法，这个行程会释放对象锁，而此线程会进入线程池等待被唤醒。 3.5只通知一个线程调用方法notify方法一次只随机通知一个线程进行唤醒。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package com.primeton.tongxin;public class Service &#123; public void methodTest(Object lock) throws InterruptedException &#123; synchronized (lock)&#123; System.out.println("begin "+ Thread.currentThread().getName()); lock.wait(); System.out.println("end "+Thread.currentThread().getName()); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; Object lock = new Object(); Thread1 thread1 = new Thread1(lock); thread1.start(); Thread2 thread2 = new Thread2(lock); thread2.start(); Thread3 thread3 = new Thread3(lock); thread3.start(); Thread.sleep(1000); Notify notify = new Notify(lock); notify.start(); &#125;&#125;class Thread1 extends Thread&#123; private Object lock; Thread1(Object lock)&#123; this.lock = lock; &#125; @Override public void run()&#123; Service service = new Service(); try &#123; service.methodTest(lock); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class Thread2 extends Thread&#123; private Object lock; Thread2(Object lock)&#123; this.lock = lock; &#125; @Override public void run()&#123; Service service = new Service(); try &#123; service.methodTest(lock); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class Thread3 extends Thread&#123; private Object lock; Thread3(Object lock)&#123; this.lock = lock; &#125; @Override public void run()&#123; Service service = new Service(); try &#123; service.methodTest(lock); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class Notify extends Thread&#123; private Object lock; Notify(Object lock)&#123; this.lock = lock; &#125; @Override public void run()&#123; synchronized (lock)&#123; lock.notify(); &#125; &#125;&#125; 结论： 方法notify只能唤醒一个线程，当多次调用notify方法时，会随机将等待wait状态的线程唤醒。 3.6唤醒所有线程将上面的lock.notify()改为 lock.notifyAll（）即可 3.7方法wait(long)的使用带一个参数的wait(long)方法是等待某一时间是否有线程对锁进行唤醒，如果超过这个时间会自动唤醒。 1234567891011121314151617181920212223242526package com.primeton.tongxin;public class MyRunnable &#123; static private Object lock = new Object(); static private Runnable runnable = new Runnable() &#123; @Override public void run() &#123; synchronized (lock)&#123; try &#123; System.out.println("wait begin " + System.currentTimeMillis()); lock.wait(5000); System.out.println("wait end " + System.currentTimeMillis()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;; public static void main(String[] args) &#123; Thread thread = new Thread(runnable); thread.start(); &#125;&#125; 当然也可以使用其他线程去唤醒。 3.8通知太早问题如果有俩个线程，负责通知的那个线程先执行了，那么wait永远都不会执行。 3.8为什么wait方法定义在呢Object中？因为这些方法时监视器的方法，而监视器其实就是对象的锁，而锁可以使任意对象。所以定义在了Object类中。 wait notify 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.primeton.tongxin;public class Resource &#123; String name; String sex; boolean flag = false; synchronized public void input(String name,String sex) throws InterruptedException &#123; if(flag)&#123; this.wait(); &#125; this.name = name; this.sex = sex; flag = true; notify(); &#125; synchronized public void print() throws InterruptedException &#123; if(!flag)&#123; this.wait(); &#125; System.out.println(name+"......"+sex); flag = false; notify(); &#125; public static void main(String[] args) &#123; Resource resource = new Resource(); Input t1 = new Input(resource); t1.start(); Output t2 = new Output(resource); t2.start(); &#125;&#125;class Input extends Thread&#123; private Resource resource; Input(Resource resource)&#123; this.resource = resource; &#125; @Override public void run()&#123; int i = 0; while(true)&#123; if(i == 0)&#123; try &#123; resource.input("mike","nan"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;else&#123; try &#123; resource.input("lili","女"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; i = (i+1)%2; &#125; &#125;&#125;class Output extends Thread&#123; private Resource resource; Output(Resource resource)&#123; this.resource = resource; &#125; @Override public void run()&#123; while(true)&#123; try &#123; resource.print(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 3.9生产者消费者问题。3.9.1单生产单消费问题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.primeton.tongxin;public class ProDucerCustomerDemo &#123; public static void main(String[] args) &#123; Resour resour = new Resour(); Producer producer1 = new Producer(resour); producer1.start(); Customer customer1 = new Customer(resour); customer1.start(); &#125;&#125;class Resour&#123; private String name; private int count = 1; private boolean flag = false; synchronized public void produce(String name) throws InterruptedException &#123; if(flag)&#123; this.wait(); &#125; this.name = name + count; Thread.sleep(100); System.out.println(Thread.currentThread().getName()+"...生产者..."+this.name); count++; flag = true; this.notify(); &#125; synchronized public void customer() throws InterruptedException &#123; if(!flag)&#123; this.wait(); &#125; Thread.sleep(100); System.out.println(Thread.currentThread().getName()+"...消费者........."+this.name); flag = false; this.notify(); &#125;&#125;class Producer extends Thread&#123; private Resour r ; Producer(Resour r)&#123; this.r = r; &#125; @Override public void run()&#123; while (true)&#123; try &#123; r.produce("烤鸭"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;class Customer extends Thread&#123; private Resour r ; Customer(Resour r)&#123; this.r = r; &#125; @Override public void run()&#123; while (true)&#123; try &#123; r.customer(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 运行结果： Thread-0…生产者…烤鸭1Thread-1…消费者………烤鸭1Thread-0…生产者…烤鸭2Thread-1…消费者………烤鸭2Thread-0…生产者…烤鸭3Thread-1…消费者………烤鸭3Thread-0…生产者…烤鸭4Thread-1…消费者………烤鸭4Thread-0…生产者…烤鸭5Thread-1…消费者………烤鸭5 结论：使用同步解决了线程安全的问题，再使用wait/notify 等待唤醒机制达到每生产出一个，就消费一个，然后在生产这么一个循环的过程。 3.9.2多生产者多消费者问题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package com.primeton.tongxin;public class ProDucerCustomerDemo &#123; public static void main(String[] args) &#123; Resour resour = new Resour(); Producer producer1 = new Producer(resour); producer1.start(); Producer producer2 = new Producer(resour); producer2.start(); Customer customer1 = new Customer(resour); customer1.start(); Customer customer2 = new Customer(resour); customer2.start(); &#125;&#125;class Resour&#123; private String name; private int count = 1; private boolean flag = false; synchronized public void produce(String name) throws InterruptedException &#123; if(flag)&#123; this.wait(); &#125; this.name = name + count; Thread.sleep(100); System.out.println(Thread.currentThread().getName()+"...生产者..."+this.name); count++; flag = true; this.notify(); &#125; synchronized public void customer() throws InterruptedException &#123; if(!flag)&#123; this.wait(); &#125; Thread.sleep(100); System.out.println(Thread.currentThread().getName()+"...消费者........."+this.name); flag = false; this.notify(); &#125;&#125;class Producer extends Thread&#123; private Resour r ; Producer(Resour r)&#123; this.r = r; &#125; @Override public void run()&#123; while (true)&#123; try &#123; r.produce("烤鸭"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;class Customer extends Thread&#123; private Resour r ; Customer(Resour r)&#123; this.r = r; &#125; @Override public void run()&#123; while (true)&#123; try &#123; r.customer(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 运行结果： Thread-1…生产者…烤鸭10Thread-0…生产者…烤鸭11Thread-3…消费者………烤鸭11Thread-1…生产者…烤鸭12Thread-0…生产者…烤鸭13Thread-3…消费者………烤鸭13 结论： 为什么在多生产多消费者使用同步了，还是出现了线程安全问题呢？ 分析：负责生产的线程被唤醒之后没有判断标记。 为了让判断标记那么把if改成while就可以了但是出现了死锁的问题。 原因是负责生产的线程唤醒了己方正在等待的线程，导致四个线程全部等待产生死锁。 解决方案：将notify改成notifyAll唤醒全部线程，就可以避免只唤醒一个己方线程了。 3.10Join方法的使用在很多情况下，主线程创建并且启动子线程，如果子线程中要进行大量的耗时运算，主线程往往早于子线程就结束了，这时，如果主线程想等待子线程执行完成后再结束，就要使用join方法了，作用就是，等待线程对象销毁。 1234567891011121314151617181920212223package com.primeton.tongxin;public class JoinDemo &#123; public static void main(String[] args) throws InterruptedException &#123; JoinTest thread = new JoinTest(); thread.start(); thread.join(); System.out.println("等待thread执行完我再执行了"); &#125;&#125;class JoinTest extends Thread&#123; @Override public void run()&#123; int sleepTime = (int)(Math.random() * 10000); try &#123; System.out.println(sleepTime); Thread.sleep(sleepTime); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行结果： 8048等待thread执行完我再执行了 结论： 方法join的作用是：使所属线程对象x 正常执行run方法中的任务，而使当前线程z进行无线阻塞，等待线程x销毁了之后 再继续执行线程z后面的代码。 join方法内部使用wait方法进行等待。 3.10.1join(long)方法和sleep(long)方法的区别方法join(long)的功能在内部是使用wait(long)方法来实现的，所以join(long)方法具有释放锁的特点，当执行完wait(long) 方法后，当前线程的锁被释放，那么其他线程就可以调用此线程的同步方法了。 而Thread.slepp(long)方法却不释放锁。 3.11ThreadLocal详解：3.11.1一.对ThreadLocal的理解 ThreadLocal，很多地方叫做线程本地变量，也有些地方叫做线程本地存储，其实意思差不多。可能很多朋友都知道ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。 这句话从字面上看起来很容易理解，但是真正理解并不是那么容易。 我们还是先来看一个例子： 12345678910111213141516class ConnectionManager &#123; private static Connection connect = null; public static Connection openConnection() &#123; if(connect == null)&#123; connect = DriverManager.getConnection(); &#125; return connect; &#125; public static void closeConnection() &#123; if(connect!=null) connect.close(); &#125;&#125; 假设有这样一个数据库链接管理类，这段代码在单线程中使用是没有任何问题的，但是如果在多线程中使用呢？很显然，在多线程中使用会存在线程安全问题：第一，这里面的2个方法都没有进行同步，很可能在openConnection方法中会多次创建connect；第二，由于connect是共享变量，那么必然在调用connect的地方需要使用到同步来保障线程安全，因为很可能一个线程在使用connect进行数据库操作，而另外一个线程调用closeConnection关闭链接。 所以出于线程安全的考虑，必须将这段代码的两个方法进行同步处理，并且在调用connect的地方需要进行同步处理。 这样将会大大影响程序执行效率，因为一个线程在使用connect进行数据库操作的时候，其他线程只有等待。 那么大家来仔细分析一下这个问题，这地方到底需不需要将connect变量进行共享？事实上，是不需要的。假如每个线程中都有一个connect变量，各个线程之间对connect变量的访问实际上是没有依赖关系的，即一个线程不需要关心其他线程是否对这个connect进行了修改的。 到这里，可能会有朋友想到，既然不需要在线程之间共享这个变量，可以直接这样处理，在每个需要使用数据库连接的方法中具体使用时才创建数据库链接，然后在方法调用完毕再释放这个连接。比如下面这样： 12345678910111213141516171819202122232425262728class ConnectionManager &#123; private Connection connect = null; public Connection openConnection() &#123; if(connect == null)&#123; connect = DriverManager.getConnection(); &#125; return connect; &#125; public void closeConnection() &#123; if(connect!=null) connect.close(); &#125;&#125;class Dao&#123; public void insert() &#123; ConnectionManager connectionManager = new ConnectionManager(); Connection connection = connectionManager.openConnection(); //使用connection进行操作 connectionManager.closeConnection(); &#125;&#125; 这样处理确实也没有任何问题，由于每次都是在方法内部创建的连接，那么线程之间自然不存在线程安全问题。但是这样会有一个致命的影响：导致服务器压力非常大，并且严重影响程序执行性能。由于在方法中需要频繁地开启和关闭数据库连接，这样不尽严重影响程序执行效率，还可能导致服务器压力巨大。 那么这种情况下使用ThreadLocal是再适合不过的了，因为ThreadLocal在每个线程中对该变量会创建一个副本，即每个线程内部都会有一个该变量，且在线程内部任何地方都可以使用，线程之间互不影响，这样一来就不存在线程安全问题，也不会严重影响程序执行性能。 但是要注意，虽然ThreadLocal能够解决上面说的问题，但是由于在每个线程中都创建了副本，所以要考虑它对资源的消耗，比如内存的占用会比不使用ThreadLocal要大。 3.11.2二深入理解ThreadLocal在上面谈到了对ThreadLocal的一些理解，那我们下面来看一下具体ThreadLocal是如何实现的。 先了解一下ThreadLocal类提供的几个方法： 1234public T get() &#123; &#125;public void set(T value) &#123; &#125;public void remove() &#123; &#125;protected T initialValue() &#123; &#125; get()方法是用来获取ThreadLocal在当前线程中保存的变量副本，set()用来设置当前线程中变量的副本，remove()用来移除当前线程中变量的副本，initialValue()是一个protected方法，一般是用来在使用时进行重写的，它是一个延迟加载方法，下面会详细说明。 首先我们来看一下ThreadLocal类是如何为每个线程创建一个变量的副本的。 先看下get方法的实现： 第一句是取得当前线程，然后通过getMap(t)方法获取到一个map，map的类型为ThreadLocalMap。然后接着下面获取到&lt;key,value&gt;键值对，注意这里获取键值对传进去的是 this，而不是当前线程t。 如果获取成功，则返回value值。 如果map为空，则调用setInitialValue方法返回value。 我们上面的每一句来仔细分析： 首先看一下getMap方法中做了什么： 可能大家没有想到的是，在getMap中，是调用当期线程t，返回当前线程t中的一个成员变量threadLocals。 那么我们继续取Thread类中取看一下成员变量threadLocals是什么： 实际上就是一个ThreadLocalMap，这个类型是ThreadLocal类的一个内部类，我们继续取看ThreadLocalMap的实现： 可以看到ThreadLocalMap的Entry继承了WeakReference，并且使用ThreadLocal作为键值。 然后再继续看setInitialValue方法的具体实现： 很容易了解，就是如果map不为空，就设置键值对，为空，再创建Map，看一下createMap的实现： 至此，可能大部分朋友已经明白了ThreadLocal是如何为每个线程创建变量的副本的： 首先，在每个线程Thread内部有一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，这个threadLocals就是用来存储实际的变量副本的，键值为当前ThreadLocal变量，value为变量副本（即T类型的变量）。 初始时，在Thread里面，threadLocals为空，当通过ThreadLocal变量调用get()方法或者set()方法，就会对Thread类中的threadLocals进行初始化，并且以当前ThreadLocal变量为键值，以ThreadLocal要保存的副本变量为value，存到threadLocals。 然后在当前线程里面，如果要使用副本变量，就可以通过get方法在threadLocals里面查找。 下面通过一个例子来证明通过ThreadLocal能达到在每个线程中创建变量副本的效果： 1234567891011121314151617181920212223242526272829303132333435363738394041public class Test &#123; ThreadLocal&lt;Long&gt; longLocal = new ThreadLocal&lt;Long&gt;(); ThreadLocal&lt;String&gt; stringLocal = new ThreadLocal&lt;String&gt;(); public void set() &#123; longLocal.set(Thread.currentThread().getId()); stringLocal.set(Thread.currentThread().getName()); &#125; public long getLong() &#123; return longLocal.get(); &#125; public String getString() &#123; return stringLocal.get(); &#125; public static void main(String[] args) throws InterruptedException &#123; final Test test = new Test(); test.set(); System.out.println(test.getLong()); System.out.println(test.getString()); Thread thread1 = new Thread()&#123; public void run() &#123; test.set(); System.out.println(test.getLong()); System.out.println(test.getString()); &#125;; &#125;; thread1.start(); thread1.join(); System.out.println(test.getLong()); System.out.println(test.getString()); &#125;&#125; 从这段代码的输出结果可以看出，在main线程中和thread1线程中，longLocal保存的副本值和stringLocal保存的副本值都不一样。最后一次在main线程再次打印副本值是为了证明在main线程中和thread1线程中的副本值确实是不同的。 总结一下： 1）实际的通过ThreadLocal创建的副本是存储在每个线程自己的threadLocals中的； 2）为何threadLocals的类型ThreadLocalMap的键值为ThreadLocal对象，因为每个线程中可有多个threadLocal变量，就像上面代码中的longLocal和stringLocal； 3）在进行get之前，必须先set，否则会报空指针异常； 如果想在get之前不需要调用set就能正常访问的话，必须重写initialValue()方法。 因为在上面的代码分析过程中，我们发现如果没有先set的话，即在map中查找不到对应的存储，则会通过调用setInitialValue方法返回i，而在setInitialValue方法中，有一个语句是T value = initialValue()， 而默认情况下，initialValue方法返回的是null。 看下面这个例子： 12345678910111213141516171819202122232425262728293031323334353637public class Test &#123; ThreadLocal&lt;Long&gt; longLocal = new ThreadLocal&lt;Long&gt;(); ThreadLocal&lt;String&gt; stringLocal = new ThreadLocal&lt;String&gt;(); public void set() &#123; longLocal.set(Thread.currentThread().getId()); stringLocal.set(Thread.currentThread().getName()); &#125; public long getLong() &#123; return longLocal.get(); &#125; public String getString() &#123; return stringLocal.get(); &#125; public static void main(String[] args) throws InterruptedException &#123; final Test test = new Test(); System.out.println(test.getLong()); System.out.println(test.getString()); Thread thread1 = new Thread()&#123; public void run() &#123; test.set(); System.out.println(test.getLong()); System.out.println(test.getString()); &#125;; &#125;; thread1.start(); thread1.join(); System.out.println(test.getLong()); System.out.println(test.getString()); &#125;&#125; 在main线程中，没有先set，直接get的话，运行时会报空指针异常。 但是如果改成下面这段代码，即重写了initialValue方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Test &#123; ThreadLocal&lt;Long&gt; longLocal = new ThreadLocal&lt;Long&gt;()&#123; protected Long initialValue() &#123; return Thread.currentThread().getId(); &#125;; &#125;; ThreadLocal&lt;String&gt; stringLocal = new ThreadLocal&lt;String&gt;()&#123;; protected String initialValue() &#123; return Thread.currentThread().getName(); &#125;; &#125;; public void set() &#123; longLocal.set(Thread.currentThread().getId()); stringLocal.set(Thread.currentThread().getName()); &#125; public long getLong() &#123; return longLocal.get(); &#125; public String getString() &#123; return stringLocal.get(); &#125; public static void main(String[] args) throws InterruptedException &#123; final Test test = new Test(); test.set(); System.out.println(test.getLong()); System.out.println(test.getString()); Thread thread1 = new Thread()&#123; public void run() &#123; test.set(); System.out.println(test.getLong()); System.out.println(test.getString()); &#125;; &#125;; thread1.start(); thread1.join(); System.out.println(test.getLong()); System.out.println(test.getString()); &#125;&#125; 就可以直接不用先set而直接调用get了。 3.11.3三.ThreadLocal的应用场景最常见的ThreadLocal使用场景为 用来解决 数据库连接、Session管理等。 12345678910private static ThreadLocal&lt;Connection&gt; connectionHolder = new ThreadLocal&lt;Connection&gt;() &#123; public Connection initialValue() &#123; return DriverManager.getConnection(DB_URL); &#125;&#125;; public static Connection getConnection() &#123; return connectionHolder.get(); &#125; 123456789101112131415//private static final ThreadLocal threadSession = new ThreadLocal(); public static Session getSession() throws InfrastructureException &#123; Session s = (Session) threadSession.get(); try &#123; if (s == null) &#123; s = getSessionFactory().openSession(); threadSession.set(s); &#125; &#125; catch (HibernateException ex) &#123; throw new InfrastructureException(ex); &#125; return s; &#125;]]></content>
      <categories>
        <category>java多线程核心技术</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程(二)对象及变量的并发访问]]></title>
    <url>%2F2019%2F02%2F14%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%BA%8C-%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%8F%98%E9%87%8F%E7%9A%84%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%2F</url>
    <content type="text"><![CDATA[Java多线程(二)对象及变量的并发访问2.1synchronized同步方法2.1.1方法内的变量为线程安全非线程安全问题存在于实例变量分中，如果是方法内部的私有变量，则不存在非线程安全问题了，也就是线程安全的了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.primeton.thread;public class HasSelfPrivateNum &#123; public void addI(String username)&#123; try&#123; int num = 0; if(username.equals("a"))&#123; num = 100; System.out.println("a set over"); Thread.sleep(2000); &#125;else&#123; num = 200; System.out.println("b set over"); &#125; System.out.println(username + " num=" + num); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; &#125; &#125; public static void main(String[] args) &#123; HasSelfPrivateNum hasSelfPrivateNum = new HasSelfPrivateNum(); ThreadA threadA = new ThreadA(hasSelfPrivateNum); threadA.start(); ThreadB threadB = new ThreadB(hasSelfPrivateNum); threadB.start(); &#125;&#125;class ThreadA extends Thread&#123; private HasSelfPrivateNum hasSelfPrivateNum; ThreadA(HasSelfPrivateNum hasSelfPrivateNum)&#123; this.hasSelfPrivateNum = hasSelfPrivateNum; &#125; @Override public void run()&#123; hasSelfPrivateNum.addI("a"); &#125;&#125;class ThreadB extends Thread&#123; private HasSelfPrivateNum hasSelfPrivateNum; ThreadB(HasSelfPrivateNum hasSelfPrivateNum)&#123; this.hasSelfPrivateNum = hasSelfPrivateNum; &#125; @Override public void run()&#123; hasSelfPrivateNum.addI("b"); &#125;&#125; 可见，方法中的变量不存在非线程安全问题，永远都是线程安全的，这是方法内部的变量时私有的特性造成的。 2.1.2实例变量非线程安全如果将上面的局部变量num换成成员变量的话就会出现线程安全问题了原因是俩个线程共同操作了同一个实例变量，在public void addI(String username) 方法前加关键字synchronized即可。可以解决线程安全的问题了。 所谓的同步，就是给要操作的代码加了一个锁，一个线程过来拿到锁了，他先执行，另一个线程等待，知道上一个线程执行完毕了，他再执行。整个过程就是多个线程争抢同一把锁的过程。 运行结果： a set overa num=100b set overb num=200 2.1.3多个对象多个锁如果将上面main方法中的代码换成： 运行结果： a set overb set overb num=200a num=100 关键字synchronized取得的锁都是对象说，而不是把一点代码或者方法当作锁，哪个线程先执行synchronized关键字的方法，哪个线程就持有该方法所属对象的锁Lock，那么其他线程只能是等待状态，前提是多个线程访问的是同一个对象。 但是如果多个线程访问多个对象，则JVM会创建多个锁，换成创建了俩个对象，产生了俩个锁。 2.1.4synchronized方法与锁对象证明线程锁是对象： 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.primeton.thread;public class PromissLock &#123; synchronized public void show()&#123; try&#123; System.out.println("begin method threadName=" + Thread.currentThread().getName()); Thread.sleep(2000); System.out.println("end method threadName=" + Thread.currentThread().getName()); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; &#125; &#125; public static void main(String[] args) &#123; PromissLock promissLock = new PromissLock(); ProTest1 thread1 = new ProTest1(promissLock); thread1.start(); ProTest1 thread2 = new ProTest1(promissLock); thread2.start(); &#125;&#125;class ProTest1 extends Thread&#123; public PromissLock promissLock; ProTest1(PromissLock promissLock)&#123; this.promissLock = promissLock; &#125; @Override public void run()&#123; promissLock.show(); &#125;&#125;class ProTest2 extends Thread&#123; public PromissLock promissLock; ProTest2(PromissLock promissLock)&#123; this.promissLock = promissLock; &#125; @Override public void run()&#123; promissLock.show(); &#125;&#125; 运行结果： begin method threadName=Thread-0end method threadName=Thread-0begin method threadName=Thread-1end method threadName=Thread-1 结论：用关键字synchronized声明的方法一定是排队运行的。 ​ 只有共享资源的读写访问才需要同步化，如果不是公共资源， ​ 那么根本没有同步的必要。 ​ A线程先持有object对象的Lock锁，B线程可以以异步的方式调用object对象中的非synchronized类型的方法 ​ A线程先持有object对象的Lock锁，B线程如果在这时调用object对象中的synchronized类型的方法则需等待 2.1.5脏读1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.primeton.thread;public class DirtyRead &#123; private String username = "AA"; private String password = "AA"; synchronized public void setValue(String username,String password)&#123; try&#123; this.username = username; Thread.sleep(5000); this.password = password; System.out.println("setValue method thread name=" +Thread.currentThread().getName()+"username=" + username + "password=" + password); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; &#125; &#125; public void getValue()&#123; System.out.println("getValue method thread name=" +Thread.currentThread().getName()+"username=" + username + "password=" + password); &#125; public static void main(String[] args) &#123; try&#123; DirtyRead dirtyRead = new DirtyRead(); DirtyTest thread = new DirtyTest(dirtyRead); thread.start(); Thread.sleep(200); dirtyRead.getValue(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; &#125; &#125;&#125;class DirtyTest extends Thread&#123; private DirtyRead dirtyRead; DirtyTest(DirtyRead dirtyRead)&#123; this.dirtyRead = dirtyRead; &#125; @Override public void run()&#123; dirtyRead.setValue("CC","CC"); &#125;&#125; 运行结果： getValue method thread name=mainusername=CCpassword=AAsetValue method thread name=Thread-0username=CCpassword=CC 结论：虽然在赋值时进行了同步，但在取值时有可能出现一些意向不到的意外，这种情况就是脏读(DirtyRead) ​ 发生脏读的情况实在读取实例变量时，这个值已经被其他线程更改过了出现脏读是因为pulbic void getValue() ​ 方法并不是同步的，所以可以在任意时间进行调用，解决办法就是加上synchronized关键字。 当A线程调用任何对象加入synchronized关键字的某个方法时，A线程就获得了这个方法锁，更准确的是说，获得了对象 的锁，所以其他线程必须等A线程执行完毕才可以调用这个方法，但是B线程可以随意调用其他的非synchronized同步方 法 2.1.6synchronized锁重入123456789101112131415161718192021222324252627282930313233package com.primeton.thread;public class LockInsert &#123; synchronized public void service1()&#123; System.out.println("service1"); service2(); &#125; synchronized public void service2() &#123; System.out.println("service2"); service3(); &#125; synchronized public void service3() &#123; System.out.println("service3"); &#125; public static void main(String[] args) &#123; LockInsert lockInsert = new LockInsert(); LockTest thread = new LockTest(lockInsert); thread.start(); &#125;&#125;class LockTest extends Thread&#123; private LockInsert lockInsert; public LockTest(LockInsert lockInsert)&#123; this.lockInsert = lockInsert; &#125; @Override public void run()&#123; lockInsert.service1(); &#125;&#125; 运行结果： service1service2service3 结论： ​ 关键字synchronized拥有锁重入的功能，也就是在使用synchronized是，当一个线程得到一个对象锁时，再次请求此 ​ 对象锁是可以再次得到该对象的锁的，这也就证明了在一个同步方法内部调用其他同步方法时，永远可以得到锁。 ​ 可重入锁的概念是：自己可以再次获取自己的内部锁。比如有一个线程获得了某个对象的锁，此时这个对象的锁还 没有被释放，当其再次想要获取这个对象的时候还是可以获得的，如果不锁重入的话，就会在成死锁。 可重入锁也支持在父子类继承的环境中： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.primeton.thread;import javax.security.auth.Subject;public class SynInsert &#123; public int i = 10; synchronized public void operate()&#123; try&#123; i--; System.out.println("i="+i); Thread.sleep(100); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; &#125; &#125; public static void main(String[] args) &#123; SynInsertTest thread = new SynInsertTest(); thread.start(); &#125;&#125;class Sub extends SynInsert&#123; synchronized public void method()&#123; try&#123; while (i &gt; 0)&#123; i--; System.out.println("i=="+i); Thread.sleep(100); this.operate(); &#125; &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; &#125; &#125;&#125;class SynInsertTest extends Thread&#123; @Override public void run()&#123; Sub sub = new Sub(); sub.method(); &#125;&#125; 运行结果： i==9i=8i==7i=6i==5i=4i==3i=2i==1i=0 2.1.7出现异常，锁自动释放当一个线程执行的代码出现异常时，其持有的锁会自动释放。 2.1.8同步不具有继承性2.2synchronized同步语句块谁用关键字synchronized声明方法在某些情况下是有弊端的，比如A线程调用同步方法执行一个长时间的任务，那么B线程 则必须等待比较长的时间，在这样的情况下可以使用语句块来解决。synchronized方法是对当前对象进行加锁，而 synchronized代码块是对某一个对象加锁。 注意：当一个线程访问对象中的一个同步代码快时，其他线程对同一个对象中的其他同步代码块的访问将被阻塞，则说明 ​ synchronized使用的对象监视器是一个。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.primeton.thread;public class SynWait &#123; public void methodA()&#123; try&#123; synchronized (this)&#123; System.out.println("A thread begin time="+System.currentTimeMillis()); Thread.sleep(2000); System.out.println("A thread end time=" +System.currentTimeMillis()); &#125; &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; &#125; &#125; public void methodB()&#123; try&#123; synchronized (this)&#123; System.out.println("B thread begin time="+System.currentTimeMillis()); Thread.sleep(2000); System.out.println("B thread end time=" +System.currentTimeMillis()); &#125; &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; &#125; &#125; public static void main(String[] args) &#123; SynWait synWait = new SynWait(); ThreadOne threadOne = new ThreadOne(synWait); threadOne.start(); ThreadTwo threadTwo = new ThreadTwo(synWait); threadTwo.start(); &#125;&#125;class ThreadOne extends Thread&#123; private SynWait synWait; ThreadOne(SynWait synWait)&#123; this.synWait = synWait; &#125; @Override public void run()&#123; synWait.methodA(); &#125;&#125;class ThreadTwo extends Thread&#123; private SynWait synWait; ThreadTwo(SynWait synWait)&#123; this.synWait = synWait; &#125; @Override public void run()&#123; synWait.methodB(); &#125;&#125; 运行结果： A thread begin time=1550213865729A thread end time=1550213867731B thread begin time=1550213867731B thread end time=1550213869731 总结： ​ synchronized同步方法和同步代码块： ​ 1）对其他同步方法或代码块调用呈阻塞状态。 ​ 2）同一时间只有一个线程可以执行同步方法或同步代码块的任务。 2.3静态同步synchronized方法与同步代码块关键字synchronized还可以应用在static静态方法上，如果这样写，那就是对当前的.java文件对应的class类进行持锁， 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.primeton.thread;public class Static &#123; synchronized public static void method1() throws InterruptedException &#123; System.out.println("thread1 begin at "+ System.currentTimeMillis()); Thread.sleep(1000); System.out.println("thread1 end at " + System.currentTimeMillis()); &#125; synchronized public static void method2() throws InterruptedException &#123; System.out.println("thread2 begin at "+ System.currentTimeMillis()); Thread.sleep(1000); System.out.println("thread2 end at " + System.currentTimeMillis()); &#125; public static void main(String[] args) &#123; Static s1 = new Static(); Static s2 = new Static(); StaticTest1 thread1 = new StaticTest1(s1); thread1.start(); StaticTest2 thread2 = new StaticTest2(s2); thread2.start(); &#125;&#125;class StaticTest1 extends Thread&#123; private Static aStatic; StaticTest1(Static aStatic)&#123; this.aStatic = aStatic; &#125; @Override public void run()&#123; try &#123; aStatic.method1(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class StaticTest2 extends Thread&#123; private Static aStatic; StaticTest2(Static aStatic)&#123; this.aStatic = aStatic; &#125; @Override public void run()&#123; try &#123; aStatic.method2(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行结果： thread1 begin at 1550217938717thread1 end at 1550217939721thread2 begin at 1550217939721thread2 end at 1550217940722 结论：虽然俩个线程持有了不同的锁，但是，synchronized方法加了static关键字了，这时的锁就不是当前的对象了 ​ 而是Class，也就是说俩个线程都是持有Class类锁。所以打印的结果会是同步的，而不是异步的。 2.4同步方法无限等待与解决同步方法容易造成死循环： 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.primeton.thread;public class Dead &#123; synchronized public void methodA()&#123; System.out.println("methodA begin"); boolean isFlag = true; while(isFlag)&#123; &#125; System.out.println("methodB begin"); &#125; synchronized public void methodB()&#123; System.out.println("methodB begin"); System.out.println("methodB end"); &#125; public static void main(String[] args) &#123; Dead dead = new Dead(); DeadTest1 thread1 = new DeadTest1(dead); thread1.start(); DeadTest2 thread2 = new DeadTest2(dead); thread2.start(); &#125;&#125;class DeadTest1 extends Thread&#123; private Dead dead; DeadTest1(Dead dead)&#123; this.dead = dead; &#125; @Override public void run()&#123; dead.methodA(); &#125;&#125;class DeadTest2 extends Thread&#123; private Dead dead; DeadTest2(Dead dead)&#123; this.dead = dead; &#125; @Override public void run()&#123; dead.methodA(); &#125;&#125; 运行结果： methodA begin 结论： ​ 线程B永远得不到执行的机会，因为线程A一直持有锁，没有释放掉，所以线程B锁死了。 可以使用同步代码块来解决这个问题。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.primeton.thread;public class Dead &#123; public void methodA()&#123; Object obj = new Object(); synchronized (obj)&#123; System.out.println("methodA begin"); boolean isFlag = true; while(isFlag)&#123; &#125; System.out.println("methodA end"); &#125; &#125; synchronized public void methodB()&#123; Object obj = new Object(); synchronized (obj)&#123; System.out.println("methodB begin"); System.out.println("methodB end"); &#125; &#125; public static void main(String[] args) &#123; Dead dead = new Dead(); DeadTest1 thread1 = new DeadTest1(dead); thread1.start(); DeadTest2 thread2 = new DeadTest2(dead); thread2.start(); &#125;&#125;class DeadTest1 extends Thread&#123; private Dead dead; DeadTest1(Dead dead)&#123; this.dead = dead; &#125; @Override public void run()&#123; dead.methodA(); &#125;&#125;class DeadTest2 extends Thread&#123; private Dead dead; DeadTest2(Dead dead)&#123; this.dead = dead; &#125; @Override public void run()&#123; dead.methodB(); &#125;&#125; 运行结果： methodA begin methodB begin methodB end 2.5，多线程的死锁。不同的线程都在等待，根本不节能被释放的锁，从而导致所有的任务都无法继续完成。多线程中死锁是必须避免的， 因为这会造成线程的假死。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.primeton.thread;public class WaitTogether implements Runnable&#123; public String username; public Object lock1 = new Object(); public Object lock2 = new Object(); public void setUsername(String username)&#123; this.username = username; &#125; @Override public void run() &#123; if(username.equals("a"))&#123; synchronized (lock1)&#123; System.out.println("username="+username); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (lock2)&#123; System.out.println("lock1 --&gt; lock2"); &#125; &#125; &#125; if(username.equals("b"))&#123; synchronized (lock2)&#123; System.out.println("username="+username); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (lock1)&#123; System.out.println("lock2 --&gt; lock1"); &#125; &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; WaitTogether target = new WaitTogether(); target.setUsername("a"); Thread t1 = new Thread(target); t1.start(); Thread.sleep(100); target.setUsername("b"); Thread t2 = new Thread(target); t2.start(); &#125;&#125; 运行结果： username=ausername=b 结论： 上面俩个线程都是互相等待对方锁，因此造成了死锁。 2.6volatile关键字主要作用：使变量在多个线程间可见 123456789101112131415161718192021222324package com.primeton.thread;public class VolatileTest extends Thread&#123; private boolean isRunning = true; public void setRunning(boolean isRunning)&#123; this.isRunning = isRunning; &#125; @Override public void run ()&#123; System.out.println("run threadName"+Thread.currentThread().getName()); System.out.println("进入 run 了"); while(isRunning == true)&#123; &#125; System.out.println("线程被停止了"); &#125; public static void main(String[] args) throws InterruptedException &#123; VolatileTest thread = new VolatileTest(); thread.start(); Thread.sleep(1000); thread.setRunning(false); System.out.println("已经赋值为false"); &#125;&#125; 运行结果： 进入run了 线程被停止了已经赋值为false 如果运行在JVM为Server服务器的环境中，出现死循环，为啥？ 原因：变量 private boolean isRunning = true；存在于公共堆栈及线程的私有堆栈中，在JVM被设置为-server模式时， 为了线程运行的效率，线程一直在私有堆栈中取得isRunning的值为true，而代码thread.setRunning(false)；虽然被执 行了，更新的却是公共堆栈中的isRunning变量值false，所以一直就是死循环的状态。 将isRunning变量用volatile关键字修饰，可以强制线程直接从公共堆栈中取得变量值。解决了死循环问题。 比较volatile和synchronized： 1）：关键字volatile是线程同步的轻量级实现，并且只能修饰变量，而synchronized可以修饰方法，以及代码块 2）：多线程访问volatile不会发生阻塞，而synchronized会出现阻塞 3）：volatile可以保证数据的可见性，但是不能保证原子性，而synchronized可以保证原子性，也可以简介保证 ​ 可见性，因为它会将私有内存和公共内存的数据做同步。 4）：关键字volatile解决的是变量在多个线程之间的可见性，而synchronized解决的是多个线程之间访问资源的同步性。 结论： 1）read和load阶段： 从主存复制变量到当前线程工作内存 2）use和assign阶段：执行代码，改变共享变量值 3）store和write阶段：用工作内存数据刷新 2.7使用原子类进行i++操作除了使用i++操作时使用synchronized关键字实现同步外，还可以使用AtomicInteger原子类实现。 原子操作是不可分割的整体，没有其他线程能够中断或检查正在原子操作的变量，一个原子类型就是一个原子操作 可用的类型，他可以在没有锁的情况下做到线程安全。 1234567891011121314151617181920212223package com.primeton.thread;import java.util.concurrent.atomic.AtomicInteger;public class AddCountThread extends Thread&#123; AtomicInteger atomicInteger = new AtomicInteger(); @Override public void run()&#123; for (int i = 0; i &lt; 10000; i++) &#123; System.out.println(atomicInteger.incrementAndGet()+Thread.currentThread().getName()); &#125; &#125; public static void main(String[] args) &#123; AddCountThread addCountThread = new AddCountThread(); Thread t1 = new Thread(addCountThread); t1.start(); Thread t2 = new Thread(addCountThread); t2.start(); Thread t3 = new Thread(addCountThread); t3.start(); &#125;&#125; 运行结果： 29995Thread-229996Thread-229997Thread-229998Thread-229999Thread-230000Thread-2 累加到了3万 2.8原子类也并不是完全安全12345678910111213141516171819202122232425262728293031323334package com.primeton.thread;import java.util.concurrent.atomic.AtomicInteger;public class AtomicNoSafe &#123; public static AtomicInteger atomicInteger = new AtomicInteger(); synchronized public void addNum()&#123; System.out.println(Thread.currentThread().getName()+"加了100之后的值："+ atomicInteger.addAndGet(100)); atomicInteger.addAndGet(1); &#125; public static void main(String[] args) throws InterruptedException &#123; AtomicNoSafe target1 = new AtomicNoSafe(); AtomicThread[] array = new AtomicThread[5]; for (int i = 0; i &lt;array.length ; i++) &#123; array[i] = new AtomicThread(target1); &#125; for (int i = 0; i &lt; array.length; i++) &#123; array[i].start(); &#125; Thread.sleep(1000); System.out.println(target1.atomicInteger.get()); &#125;&#125;class AtomicThread extends Thread&#123; private AtomicNoSafe atomicNoSafe; public AtomicThread(AtomicNoSafe atomicNoSafe)&#123; this.atomicNoSafe = atomicNoSafe; &#125; @Override public void run()&#123; atomicNoSafe.addNum(); &#125;&#125; 运行结果： 100 501 200 400 300 addAndGet方法时原子的，但是方法和方法之间的调用不是原子的。必须同步。 100 201 302 403 504 2.9synchronizd代码块有volatile同步的功能12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.primeton.thread;import java.io.Serializable;public class Service &#123; private boolean isRunning = true; public void runMethod()&#123; System.out.println("开始运行"); while(isRunning == true)&#123; &#125; System.out.println("停下来了"); &#125; public void stopMethod()&#123; isRunning = true; &#125; public static void main(String[] args) &#123; Service service = new Service(); ThreadC threadC = new ThreadC(service); threadC.start(); ThreadD threadD = new ThreadD(service); threadD.start(); System.out.println("已经发起停止命令了"); &#125;&#125;class ThreadC extends Thread&#123; private Service service; ThreadC(Service service)&#123; this.service = service; &#125; @Override public void run()&#123; service.runMethod(); &#125;&#125;class ThreadD extends Thread&#123; private Service service; ThreadD(Service service)&#123; this.service = service; &#125; @Override public void run()&#123; service.stopMethod(); &#125;&#125; 运行结果： 已经发起停止命令了开始运行 结论：出现死循环的状态原因是各个线程之间的数据没有可视性造成的。 修改runmethod代码 12345678910public void runMethod()&#123; System.out.println("开始运行"); String anything = new String(); while(isRunning == true)&#123; synchronized (anything)&#123; &#125; &#125; System.out.println("停下来了");&#125;]]></content>
      <categories>
        <category>java多线程核心技术</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java多线程编程核心技术]]></title>
    <url>%2F2019%2F02%2F13%2Fjava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[java多线程编程核心技术一Java多线程技能1.1线程的概念：​ 线程可以理解成是在进程中独立运行的子任务 ​ 注意：多线程是异步的，代码的顺序不是线程执行的顺序，线程被调用的时机是随机的，一个进程正在运行时，至少 会有一个线程在运行， 1.2继承Thread类：1.2.1线程的调用随机性：1，Thread类的结构： public class Thread implements Runnable 2，创建一个自定义的 线程类： 123456789package com.primeton.thread;public class MyThread extends Thread&#123; @Override public void run()&#123; super.run(); System.out.println("MyThread"); &#125;&#125; ​ 运行类代码如下： 1234567891011package com.primeton.test;import com.primeton.thread.MyThread;public class ThreadTest &#123; public static void main(String[] args) &#123; MyThread myThread = new MyThread(); myThread.start(); System.out.println("运行结束！！！"); &#125;&#125; 运行结果： ​ 运行结束！！！ ​ MyThread 分析：从运行结果看，run方法执行的时间比较晚，这也就说明使用多线程技术时，代码的运行结果与代码执行顺序或者 ​ 调用顺序是无关的。 ​ 线程是一个子任务，CPU以不确定的形式，或者说以随机的时间来调用线程中的run方法，所以出现上面的结果 注意：如果多次调用start()方法，则会出现异常Exception in thread “main” java.lang.IllegalThreadStateExceprton 1.2.2线程的随机性：线程类： 123456789101112131415161718package com.primeton.thread;import java.util.Random;public class MyThread02 extends Thread&#123; @Override public void run()&#123; try &#123; for (int i = 0; i &lt;10 ; i++) &#123; int time = (int)(Math.random() * 1000); Thread.sleep(time); System.out.println("run=" + Thread.currentThread().getName()); &#125; &#125;catch (Exception e)&#123; System.out.println(e.getStackTrace()); &#125; &#125;&#125; 测试类： 1234567891011121314151617181920package com.primeton.test;import com.primeton.thread.MyThread02;public class ThreadTest02 &#123; public static void main(String[] args) &#123; try&#123; MyThread02 thread = new MyThread02(); thread.setName("mythread"); thread.start(); for (int i = 0; i &lt;10 ; i++) &#123; int time = (int)(Math.random() * 1000); Thread.sleep(time); System.out.println("main=" + Thread.currentThread().getName()); &#125; &#125;catch(Exception e)&#123; System.out.println(e.getStackTrace()); &#125; &#125;&#125; 运行结果： run=mythreadmain=mainrun=mythreadmain=mainmain=mainrun=mythreadrun=mythreadrun=mythreadmain=mainmain=mainrun=mythreadrun=mythreadmain=mainmain=mainrun=mythreadrun=mythreadmain=mainmain=mainmain=mainrun=mythread 1.2.3注意：执行start()方法的顺序不代表线程启动的顺序。 代码示例： 线程类： 123456789101112package com.primeton.thread;public class MyThread03 extends Thread &#123; private int i; public MyThread03(int i)&#123; this.i = i; &#125; @Override public void run()&#123; System.out.println("i=" + i); &#125;&#125; 运行测试类： 123456789101112131415161718package com.primeton.test;import com.primeton.thread.MyThread03;public class ThreadTest03 &#123; public static void main(String[] args) &#123; MyThread03 thread1 = new MyThread03(1); thread1.start(); MyThread03 thread2 = new MyThread03(2); thread2.start(); MyThread03 thread3 = new MyThread03(3); thread3.start(); MyThread03 thread4 = new MyThread03(4); thread4.start(); MyThread03 thread5 = new MyThread03(5); thread5.start(); &#125;&#125; 运行结果： i=2i=4i=1i=3i=5 1.2.4继承Thread总结：Thread类实现了Runnable接口，他们之间是多态的关系 使用继承Thread类的方式创建新线程时，最大的局限就是不支持多继承，以为java语言的特性就是单继承，所以为了 支持多继承，完全可以实现Runnable接口的方式，一边实现，一边继承。 1.3实现Runnable’接口如果欲创建的线程类已经有一个父类了，这时就不能再继承Thread类了，因为java不支持多继承， 所以需要实现Runnable接口来应对这样的情况。 Thread类有俩个构造函数，Thread(Runnable target) Thread(Runnable target,String name)可以传递Runnable接口， 说明构造函数支持传入一个Runnable对象。 1.3.1示例一：线程类： 12345678package com.primeton.thread;public class MyRunnable01 implements Runnable &#123; @Override public void run()&#123; System.out.println("运行中。。。。。"); &#125;&#125; 测试运行类： 123456789101112package com.primeton.test;import com.primeton.thread.MyRunnable01;public class RunnableTest01 &#123; public static void main(String[] args) &#123; Runnable run = new MyRunnable01(); Thread thread = new Thread(run); thread.start(); System.out.println("运行结束。。。"); &#125;&#125; 运行结果： 运行结束。。。运行中。。。。。 1.3.2实例变量与线程安全自定义线程类中的实例变量针对其他线程可以有共享和不共享之分，这在多个线程之间进行交互时是重要的一个技术点 1.3.2.1示例：变量不共享线程类代码： 123456789101112package com.primeton.thread;public class MyRunnable02 implements Runnable &#123; private int count = 5; @Override public void run()&#123; while (count &gt; 0)&#123; count--; System.out.println("由"+Thread.currentThread().getName()+"计算,count="+count); &#125; &#125;&#125; 运行类代码： 12345678910111213141516171819package com.primeton.test;import com.primeton.thread.MyRunnable02;public class RunnableTest02 &#123; public static void main(String[] args) &#123; Runnable target = new MyRunnable02(); Thread thread = new Thread(target); thread.start(); Runnable target2 = new MyRunnable02(); Thread thread2 = new Thread(target2); thread2.start(); Runnable target3 = new MyRunnable02(); Thread thread3 = new Thread(target3); thread3.start(); &#125;&#125; 运行结果： 由Thread-0计算,count=4由Thread-0计算,count=3由Thread-1计算,count=4由Thread-1计算,count=3由Thread-1计算,count=2由Thread-0计算,count=2由Thread-1计算,count=1由Thread-2计算,count=4由Thread-2计算,count=3由Thread-1计算,count=0由Thread-0计算,count=1由Thread-0计算,count=0由Thread-2计算,count=2由Thread-2计算,count=1由Thread-2计算,count=0 总结上面示例： ​ 一共创建了3个线程，每个线程都有自己的count变量，自己减少自己的count值，这种情况就是变量的不共享。 ​ 不会存在多个线程访问同一个实例变量的情况。 1.3.2.2示例：变量共享共享数据的情况就是多个线程可以访问同一个变量，比如投票功能的软件时，多个线程可以同时处理同一个人的票数 通过在run方法前加入synchronized关键字，使多个线程在执行run方法时，以排队的方式进行处理，当一个线程调用 run前，先判断run方法有没有被上锁，如果上锁，说明有其他线程正在调用run方法，必须等其他线程对run方法调用 结束后才可以执行run方法。 synchronized可以在任意对象及方法上加锁，而加锁的这段代码被称为互斥区或者临界区 模拟一个servlet 123456789101112131415161718package com.primeton.thread;public class LoginServlet &#123; private String username; private String password; public static void doPost(String username,String password)&#123; try &#123; username = username; if(username.equals("a"))&#123; Thread.sleep(6000); &#125; password = password; System.out.println("username="+username + " password="+password); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 线程类 12345678910package com.primeton.test;import com.primeton.thread.LoginServlet;public class ALogin extends Thread &#123; @Override public void run()&#123; LoginServlet.doPost("a","aa"); &#125;&#125; 12345678910package com.primeton.test;import com.primeton.thread.LoginServlet;public class BLogin extends Thread &#123; @Override public void run()&#123; LoginServlet.doPost("b","bb"); &#125;&#125; 12345678910package com.primeton.test;public class RunLoginThread &#123; synchronized public static void main(String[] args) &#123; ALogin a = new ALogin(); a.start(); BLogin b = new BLogin(); b.start(); &#125;&#125; 运行结果： username=b password=bbusername=a password=aa 1.3.2.3留意i–与syso的异常线程类： 123456789package com.primeton.thread;public class MyThread04 extends Thread &#123; private int i = 5; @Override public void run()&#123; System.out.println("i=" + (i--) + "threadName=" + Thread.currentThread().getName()); &#125;&#125; 测试类： 12345678910111213141516171819package com.primeton.test;import com.primeton.thread.MyThread04;public class ThreadTest04 &#123; public static void main(String[] args) &#123; MyThread04 target = new MyThread04(); Thread t1 = new Thread(target); Thread t2 = new Thread(target); Thread t3 = new Thread(target); Thread t4 = new Thread(target); Thread t5 = new Thread(target); t1.start(); t2.start(); t3.start(); t4.start(); t5.start(); &#125;&#125; 运行结果： i=4threadName=Thread-3i=3threadName=Thread-4i=2threadName=Thread-5i=5threadName=Thread-2i=5threadName=Thread-1 结论：虽然println方法内部是同步的，但是i–的操作缺失在进入println方法之前发生的，所以有线程安全问题的概率 所以为了防止发生非线程安全问题，还是应该继续使用同步的方法。 1.3.2.4currentThread()方法currentThread方法可以返回代码段正在被哪个线程调用的信息。 1.3.2.5 isAlive()方法判断当前线程时候处于活动状态 线程类： 12345678package com.primeton.thread;public class IsAlive extends Thread &#123; @Override public void run()&#123; System.out.println("run=" + this.isAlive()); &#125;&#125; 测试类： 123456789101112package com.primeton.test;import com.primeton.thread.IsAlive;public class IsAliveTest &#123; public static void main(String[] args) &#123; IsAlive thread = new IsAlive(); System.out.println("begin ==" + thread.isAlive()); thread.start(); System.out.println("end ==" + thread.isAlive()); &#125;&#125; 结论：方法isAlive()的作用是测试线程时候处于活动状态，活动状态就是线程已经启动，且尚未终止，线程政处于正在运行或者准备开始运行的状态，就认为线程时存活的。 另外在使用isAlive()方法时，如果将线程对象以构造函数的方式传递给Thread对象，进行start启动时，由于Thread.currentThread()和this的差异，运行结果会有所不同。 测试类： 1234567891011121314151617181920package com.primeton.thread;public class IsAliveGouzao extends Thread &#123; public IsAliveGouzao()&#123; System.out.println("IsAliveGouzao -- begin"); System.out.println("Thread.currentThread().getName()="+Thread.currentThread().getName()); System.out.println("Thread.currentThread().isAlive()="+Thread.currentThread().isAlive()); System.out.println("this.getName()=" + this.getName()); System.out.println("this.isAlive()=" + this.isAlive()); System.out.println("IsAliveGouzao -- end"); &#125; public void run()&#123; System.out.println("run -- begin"); System.out.println("Thread.currentThread().getName()="+Thread.currentThread().getName()); System.out.println("Thread.currentThread().isAlive()="+Thread.currentThread().isAlive()); System.out.println("this.getName()=" + this.getName()); System.out.println("this.isAlive()=" + this.isAlive()); System.out.println("run-- end"); &#125;&#125; 测试类： 1234567891011121314package com.primeton.test;import com.primeton.thread.IsAliveGouzao;public class IsAliveTest02 &#123; public static void main(String[] args) &#123; IsAliveGouzao target = new IsAliveGouzao(); Thread thread = new Thread(target); System.out.println("main begin t1 isAlive=" + thread.isAlive()); thread.setName("A"); thread.start(); System.out.println("main end t1 isLive=" + thread.isAlive()); &#125;&#125; 运行结果： IsAliveGouzao – beginThread.currentThread().getName()=mainThread.currentThread().isAlive()=truethis.getName()=Thread-0this.isAlive()=falseIsAliveGouzao – endmain begin t1 isAlive=falsemain end t1 isLive=truerun – beginThread.currentThread().getName()=AThread.currentThread().isAlive()=truethis.getName()=Thread-0this.isAlive()=falserun– end 1.3.2.6sleep()方法方法sleep的作用是在指定的毫秒数让当前正在执行的线程休眠，这个正在执行的线程是指this.currentThread()返回的线程 示例： 线程类： 1234567891011121314package com.primeton.thread;public class Sleep extends Thread &#123; @Override public void run()&#123; try &#123; System.out.println("run threadName=" + this.currentThread().getName()+" begin"); Thread.sleep(2000); System.out.println("run threadName=" + this.currentThread().getName()+" end" ); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 测试类： 123456789101112package com.primeton.test;import com.primeton.thread.Sleep;public class SleepTest &#123; public static void main(String[] args) &#123; Sleep thread = new Sleep(); System.out.println("begin = " + System.currentTimeMillis()); thread.run(); System.out.println("end = " + System.currentTimeMillis()); &#125;&#125; 测试结果； begin = 1550123724929run threadName=main beginrun threadName=main endend = 1550123726931 线程休眠了俩秒钟 1.3.2.7getId()方法getId()方法的作用是取得线程的唯一标识 12345678package com.primeton.thread;public class GetId&#123; public static void main(String[] args) &#123; Thread thread = Thread.currentThread(); System.out.println(thread.getName() + "" + thread.getId()); &#125;&#125; 运行结果： main1 结论：当前执行线程名称为main，线程id是1 1.4暂停线程：暂停线程意味着此线程还可以恢复运行，在java多线程中可以使用suspend()方法暂停线程，使用resume()方法恢复线程 1.5yield方法yield方法的作用是放弃当前的CPU资源，将它让给其他的任务去占用CPU执行时间，但是放弃的时间不确定，有可能刚刚放弃马上获得CPU的时间片 1234567891011121314151617181920package com.primeton.thread;public class Yield extends Thread &#123; @Override public void run()&#123; long beginTime = System.currentTimeMillis(); int count = 0; for (int i = 0; i &lt; 500000; i++) &#123; Thread.yield(); count = count + (i + 1); &#125; long endTime = System.currentTimeMillis(); System.out.println("用时："+(endTime - beginTime) +"毫秒"); &#125; public static void main(String[] args) &#123; Yield thread = new Yield(); thread.start(); &#125;&#125; 不加Thread.yield()用时5毫秒 加了用时38毫秒 1.6线程的优先级：操作系统中线程可以划分优先级，优先级较高的线程得到的CPU资源较多，也就是CPU优先执行优先级较高的线程对象中的任务。 设置线程的优先级使用setPriority()方法 在java中，线程的优先级分为1-10这10个等级，如果小于1或大于10，抛出throw new IllegalArfumentException() JDK中使用3个常量来预置定义优先级的值。 public final static int MIN_PROORITY = 1; public final static int NORM_PROORITY = 5; public final static int MAX_PROORITY = 10; 线程类 12345678910111213141516package com.primeton.thread;public class Priority01 extends Thread &#123; @Override public void run()&#123; long beginTime = System.currentTimeMillis(); long result = 0; for (int i = 0; i &lt; 10; i++) &#123; for (int j = 0; j &lt; 50000; j++) &#123; result = result+ j; &#125; &#125; long endTime = System.currentTimeMillis(); System.out.println("thread1 use time:"+(endTime-beginTime)); &#125;&#125; 12345678910111213141516package com.primeton.thread;public class Priority02 extends Thread &#123; @Override public void run()&#123; long beginTime = System.currentTimeMillis(); long result = 0; for (int i = 0; i &lt; 10; i++) &#123; for (int j = 0; j &lt; 50000; j++) &#123; result = result + j; &#125; &#125; long endTime = System.currentTimeMillis(); System.out.println("thread2 use time: " + (endTime - beginTime)); &#125;&#125; 测试类： 123456789101112131415package com.primeton.test;import com.primeton.thread.Priority01;import com.primeton.thread.Priority02;public class PriorityTest &#123; public static void main(String[] args) &#123; Priority01 thread1 = new Priority01(); thread1.setPriority(10); thread1.start(); Priority02 thread2 = new Priority02(); thread2.setPriority(1); thread2.start(); &#125;&#125; 运行结果： thread1 use time:4thread2 use time: 9 1.7守护线程在java中有俩种线程，一种是用户线程，另一种就是守护线程。 守护线程是一种特殊的线程，他的特性有陪伴的含义，当进程中不存在非守护线程了，则守护线程就自动销毁了， 典型的守护线程就是垃圾回收线程， 守护线程的作用就是为其他线程的运行提供便利服务，最典型的应用就是GC（垃圾回收器）。]]></content>
      <categories>
        <category>java多线程核心技术</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3—]]></title>
    <url>%2F2019%2F01%2F29%2Fcss3%E2%80%94%2F</url>
    <content type="text"><![CDATA[CSS3一，边框：1，使用css3可以创建圆角边框，添加阴影框。 2，常见的边框属性有： ​ 1，border-radius ​ 2，box-shadow ​ 3，border-image（IE浏览器不支持） 3，css3圆角： ​ 123456.box&#123; width: 100px; height: 100px; border: 2px solid; border-radius: 25px; &#125; 4，css3盒阴影： 1234div &#123; box-shadow: 10px 10px 5px #888888; &#125; 5，border-image：可以使用图像创建一个边框，在div中还创建边框 123div&#123; border-image:url(1.jpg) 30 30 round;&#125; 二，CSS3圆角：1，使用 CSS3 border-radius 属性，你可以给任何元素制作 “圆角”。 2，指定背景颜色的元素圆角 3，指定边框的元素圆角 4，指定背景图片的元素圆角]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3_flex布局]]></title>
    <url>%2F2019%2F01%2F29%2Fcss3-flex%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[css3_flex布局1，布局方式：1，传统布局方式： ​ 盒子模型： content-box –&gt;如果给一个div加上padding，border或者marging盒子会变大，向外扩展 ​ flex布局：border-box，向内扩展，加上padding，border盒子不会变大 ​ 以上content-box和border-box都是box-sizing的属性 2，之前的css版本提供了一个内置的计算函数： ​ calc(100px - 20px),数值和减号之间要有一个空格 3，使用postCss可以自动添加浏览器前缀 2，父级元素：1，display:flex ​ 注意：如果使用弹性布局，子元素就不需要浮动了。 2，父级元素其他属性： 1，justify-content: 子元素水平排列方式 ​ 属性： center：居中 flex-start：居左 flex-end：居右 ​ space-between：两端对齐 ​ space-around：每个元素拉手分布 2，align-items：子元素垂直排列 ​ center：居中 flex-start：居上 flex-end：居下 3，flex-direction： 排列方式 ​ 默认的是： row 横向排列 ​ row-reverse：横向翻过排列 ​ column：纵向排列 ​ column-reverse：纵向翻过排列 4，flex-wrap：子元素是否在一行显示 ​ 默认：wrap：不换行 ​ nowrap：换行 5，align-content：多行时，垂直排列 ​ center：居中 ​ flex-start：居上 ​ flex-end：居下 3，子级元素：1，flex：1 1指的是一个系数，将父级分为俩份，每个占一份 2，flex-grow：1 定义子元素放大比例 3，align-self：用来覆盖父级align-items： 垂直排列]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jenkins+SVN+Maven自动化部署]]></title>
    <url>%2F2018%2F12%2F25%2FJenkins-SVN-Maven%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[Jenkins+SVN+Maven自动化部署一，Devops1，devops是开发和运维的缩写。 2，devops是一组实践，强调(IT研发，运维，测试)在应用和服务生命周期中的协作，和沟通，强调整个组织的合作，以及 交付和基础设施变更的自动化，从而实现持续集成，持续部署，持续交付。 DevOps平台四大模块 ​ 项目管理：创建项目，项目需求 ​ 运维平台：监控，日志收集， ​ 持续交付：提交完代码，自动打包，构建 ​ 代码托管：svn或者gitlab代码提交 二、服务介绍很多事情不是光运维就可以决定的，还需要跟研发交流，我这里只是演示一个大概的持续交付的流程~ 2.1 Jenkins介绍Jenkins只是一个平台，真正运作的都是插件。这就是jenkins流行的原因，因为jenkins什么插件都有Hudson是Jenkins的前身，是基于Java开发的一种持续集成工具，用于监控程序重复的工作，Hudson后来被收购，成为商业版。后来创始人又写了一个jenkins，jenkins在功能上远远超过hudson 2.2 Maven 介绍maven的用途maven是一个项目构建和管理的工具，提供了帮助管理 构建、文档、报告、依赖、scms、发布、分发的方法。可以方便的编译代码、进行依赖管理、管理二进制库等等。maven的好处在于可以将项目过程规范化、自动化、高效化以及强大的可扩展性利用maven自身及其插件还可以获得代码检查报告、单元测试覆盖率、实现持续集成等等。 maven的核心概念介绍 Pompom是指project object Model。pom是一个xml，在maven2里为pom.xml。是maven工作的基础，在执行task或者goal时，maven会去项目根目录下读取pom.xml获得需要的配置信息 pom文件中包含了项目的信息和maven build项目所需的配置 Artifact这个有点不好解释，大致说就是一个项目将要产生的文件，可以是jar文件，源文件，二进制文件，war文件，甚至是pom文件。每个artifact都由groupId:artifactId:version组成的标识符唯一识别。需要被使用(依赖)的artifact都要放在仓库(见Repository)中 RepositoriesRepositories是用来存储Artifact的。如果说我们的项目产生的Artifact是一个个小工具，那么Repositories就是一个仓库，里面有我们自己创建的工具，也可以储存别人造的工具，我们在项目中需要使用某种工具时，在pom中声明dependency，编译代码时就会根据dependency去下载工具（Artifact），供自己使用。 Build Lifecycle是指一个项目build的过程。maven的BuildLifecycle分为三种，分别为default（处理项目的部署）、clean（处理项目的清理）、site（处理项目的文档生成）。他们都包含不同的lifecycle。Build Lifecycle是由phases构成的 2.3 SVN介绍 SVN是近年来崛起的非常优秀的版本管理工具，与CVS管理工具一样，SVN是一个固态的跨平台的开源的版本控制系统。SVN版本管理工具管理者随时间改变的各种数据。这些数据放置在一个中央资料档案库repository中，这个档案库很像一个普通的文件服务器或者FTP服务器，但是，与其他服务器不同的是，SVN会备份并记录每个文件每一次的修改更新变动。这样我们就可以把任意一个时间点的档案恢复到想要的某一个旧的版本，当然也可以直接浏览指定的更新历史记录。 2.4 Nexus介绍 maven的仓库只有两大类：1.本地仓库 2.远程仓库，在远程仓库中又分成了3种：1 中央仓库 2 私服 3 其它公共库。 私服是一种特殊的远程仓库，它是架设在局域网内的仓库服务，私服代理广域网上的远程仓库，供局域网内的Maven用户使用。当Maven需要下载构件的时候，它从私服请求，如果私服上不存在该构件，则从外部的远程仓库下载，缓存在私服上之后，再为Maven的下载请求提供服务。我们还可以把一些无法从外部仓库下载到的构件上传到私服上。 Maven私服的 特性： 1.节省自己的外网带宽：减少重复请求造成的外网带宽消耗 2.加速Maven构件：如果项目配置了很多外部远程仓库的时候，构建速度就会大大降低 3.部署第三方构件：有些构件无法从外部仓库获得的时候，我们可以把这些构件部署到内部仓库(私服)中，供内部maven项目使用 4.提高稳定性，增强控制：Internet不稳定的时候，maven构建也会变的不稳定，一些私服软件还提供了其他的功能 5.降低中央仓库的负荷：maven中央仓库被请求的数量是巨大的，配置私服也可以大大降低中央仓库的压力 因此我们在实际的项目中通常使用私服来间接访问中央仓库，项目通常不直接访问中央仓库 三、环境搭建 首先最新版本2.97 只支持java1.8，我们需要将jdk版本设置为1.8 tomcat的版本最好也是8.0.x版本或者7.0，如果使用8.5可能会有问题 系统我们使用Centos7 3.1安装jdk $ wget http://download.oracle.com/otn-pub/java/jdk/8u144-b01/090f390dda5b47b9b721c7dfaa008135/jdk-8u144-linux-x64.tar.gz这种方式是不行的下载之后解压不了，直接先去下载下来再win7客户端使用sftp服务传上去。 使用sftp方式上传： lcd d:/packages (路径填自己jdk的路径不要有中文) put jdk-8u121-linux-x64.tar.gz 3，tar -zxf jdk-8u121-linux-x64.tar.gz -C /usr/local （路径随便） 4，ln -s /usr/local/jdk1.8.0_121 /usr/local/jdk （建立一个软连接方便操作） 5，vim /etc/profile （编辑etc目录下的profile文件） 6，在上述文件中最上面添加： export JAVA_HOME=/usr/local/jdk export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar export PATH=$JAVA_HOME/bin:$PATH pathmunge () { 直接在pathmunge上面添加三句export就行 ​ 7，使用 java -version 查看jdk的版本 出现以下信息说明搞定： ​ openjdk version “1.8.0_65” OpenJDK Runtime Environment (build 1.8.0_65-b17) OpenJDK 64-Bit Server VM (build 25.65-b01, mixed mode) 3.2安装Jenkins1，首先需要jdk我们已经安装好了 2，使用yum的方式安装jenkins ​ sudo wget -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat/jenkins.repo ​ sudo rpm –import https://jenkins-ci.org/redhat/jenkins-ci.org.key ​ sudo yum install jenkins 3，接下来配置jenkins端口 ​ vi /etc/sysconfig/jenkins ​ 查找/JENKINS_PORT，修改JENKINS_PORT=”8080”，默认为“8080”，我修改为了8088 4，启动Jenkins： ​ service jenkins restart 5，在浏览器输入 ： http://192.168.10.138:8088 (ip地址填自己主机的ip) 6，发现不能访问，需要关闭主机的 防火墙功能。linux默认使用的firewall我们替换成为iptables 7，替换防火墙为iptables：​ 0，安装iptables： ​ yum install iptables-services ​ 1，停止firewall： ​ systemctl stop firewalld ​ systemctl mask firewalld ​ 或者：systemctl stop firewalld.service &amp;&amp; systemctl disable firewalld.service 关闭服务并且禁止开机自启动 ​ 2，开放443端口： ​ iptables -A INPUT -p tcp –dport 443 -j ACCEPT 3，保存上述规则： ​ service iptables save ​ 4，开启服务 ​ systemctl restart iptables.service ​ 5，编辑防火墙文件 ​ vi /etc/sysconfig/iptables ​ 添加80和3306端口 等等（自己配置）： ​ -A INPUT -m state –state NEW -m tcp -p tcp –dport 80 -j ACCEPT #80端口开放 ​ -A INPUT -m state –state NEW -m tcp -p tcp –dport 3306 -j ACCEPT #3306端口开放 ​ -I INPUT -s 113.106.93.110 -p tcp –dport 8089 -j DROP #禁止指定IP访问 8089 ​ -I INPUT -s 113.106.93.110 -p tcp –dport 8080 -j ACCEPT #开放固定ipIP访问 8080 ​ 6，重启防火墙使配置文件生效 ​ systemctl restart iptables.service ​ 7，设置iptables防火墙为开机自动启动： ​ systemctl enable iptables.service ​ 8，关闭SELINUX： ​ vi /etc/selinux/config ​ 注释以下配置 ​ SELINUX=enforcing ​ SELINUXTYPE=targeted ​ 增加以下配置 ​ SELINUX=disabled ​ 使配置立即生效 ​ setenforce 0 ​ 9，上面工作完成，直接访问，会出现一个登陆的界面，需要密码。只需要将他提示的文件下的密码复制过来 ​ cat /var/lib/jenkins/secrets/initialAdminPassword ​ 10，到此jenkins安装就完成了 3,3安装tomcat1，使用sftp服务将tomcat的压缩包上传到linux 2，解压，然后进入bin目录执行 startup.sh 3, 浏览器访问 8080 端口 3.4安装maven1，使用sftp服务将maven的包上传到linux上面 2，tar -zxf apache-maven-3.5.0-bin.tar.gz -C /usr/local （解压安装包到usrl/local目录下） 3，ln -s /usr/local/apache-maven-3.5.0/ /usr/local/maven （建立软连接方便后续操作） 4，编辑etc目录下的profile文件：vim /etc/profile 5，source /etc/profile (使配置文件生效) 6，验证 ： mvn -v 出现下面内容说明成功： Apache Maven 3.5.0 (ff8f5e7444045639af65f6095c62210b5713f426; 2017-04-03T12:39:06-07:00)Maven home: /usr/local/mavenJava version: 1.8.0_121, vendor: Oracle CorporationJava home: /usr/local/jdk1.8.0_121/jreDefault locale: en_US, platform encoding: UTF-8OS name: “linux”, version: “3.10.0-327.el7.x86_64”, arch: “amd64”, family: “unix” 3.5安装svn服务1，yum -y install subversion （yum方式安装subversion） 2，如果需要查看安装位置： rpm -ql subversion 3，在根目录下的var目录创建版本库目录： cd /var mkdir svn cd svn mkdir svnrepos 4，创建版本库：svnadmin create /var/svn/svnrepos/xxxxxx (xxxxx是自己起的项目名) 5，配置修改：进入conf文件夹看到三个文件 ​ authz：负责账号权限的管理，控制账号是否读写权限 ​ passwd：负责账号和密码的用户名单管理 ​ svnserve.conf：svn服务器配置文件 ​ 1，vi authz–&gt;在文件的末尾添加 [/] 账号名称1=rw 账号名称2=rw ​ 2，vipasswd–&gt;账号密码文件无需做修改，也是直接将账号和密码信息追加到文件中即可，注意格式为： ​ 账号 = 密码 比如：admin=123123 ​ 3，vi svnserve.conf –》将文件里的这些注释去掉： ​ anon-access = read ​ auth-access=write ​ authz-db = authz ​ realm = My First Repository 6,启动svn服务： svnserve -d -r /var/svn/svnrepos 7，在eclipse的svn资源研究库创建一个新的资源位置，然后搞一个工程上传测试ok了。 3.6至此所有的准备工作都已经做完了，我们可以去进行实际操作了！！！四，搭建自动化部署环境1，首先需要配置jenkins： ​ 系统管理 ——&gt;全局工具配置——-&gt;::::: ​ 1,Maven的settings.xml配置： ​ 选择文件系统中的setting文件这个选项。linux命令echo $MAVEN_HOME查看settings文件目录 ​ 2，JDK配置 ​ 新增jdk，取消自动安装，nux命令echo $java_HOME查看jdk文件目录 ​ 3，Maven配置 ​ 新增maven，取消自动安装，nux命令echo $MAVEN_HOME查看maven路径 ​ 系统管理———–&gt;插件管理—————–&gt;:::::: ​ 1，安装Maven Integration插件 ​ 2，安装Deploy to container插件 2，配置tomcat目录下的conf中的toncat_user文件添加如下内容 ==== ==== ==== ==== ==== 3，创建构建任务： ​ 命名项目名称：然后选择创建一个自由风格的项目 ​ 进入配置 ​ ==配置源码管理：== 上面的wenxin用户名密码就是在Jenkins文件中配置的允许访问的用户名和密码 ​ ==配置构建操作：== ​ ==配置构建后操作：== 上面的tomcat_user就是上面再tmocat_user文件中配置的用户名和密码 ​ ==配置钩子函数（触发器）：==只要代码提交直接出发钩子函数，去构建。 ​ 在jenkins版本库中，进入hooks文件：拷贝post-commit.tmpl文件并且命名为 post-commit ​ cp post-commit.tmpl post-commit ​ 编辑这个文件将里面的注释然后添加curl指令： ​ vim post-commit ​ curl -X post -v -u admin:ba3cc30fc70f4345b92ff5d7aaff8113 http://192.168.10.138:8088/job/devops/build?token=DEV_TOKEN]]></content>
      <categories>
        <category>自动化部署</category>
        <category>持续集成</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
        <tag>Svn</tag>
        <tag>Maven</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue02_组件化编程]]></title>
    <url>%2F2018%2F12%2F14%2FVue0202-%E7%BB%84%E4%BB%B6%E5%8C%96%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Vue02_组件化编程1，使用vue-cli创建模板项目1）：vue是vue官方提供的脚手架工具 2）：github:https://github.com/vue/js/vue-cli 3）：作用：从 https://github.com/vuejs-templates 下载模板项目 2，创建vue项目1）npm install -g vue-cli 2）vue init webpack vue_demo 3）cd vue_demo 4）npm install 5）npm run dev 6）访问：http://localhost:8080 3，模板项目结构|– build : webpack 相关的配置文件夹(基本不需要修改)|– dev-server.js : 通过 express 启动后台服务器|– config: webpack 相关的配置文件夹(基本不需要修改)|– index.js: 指定的后台服务的端口号和静态资源文件夹|– node_modules|– src : 源码文件夹|– components: vue 组件及其相关资源文件夹|– App.vue: 应用根主组件|– main.js: 应用入口 js|– static: 静态资源文件夹|– .babelrc: babel 的配置文件|– .eslintignore: eslint 检查忽略的配置|– .eslintrc.js: eslint 检查的配置|– .gitignore: git 版本管制忽略的配置|– index.html: 主页面文件|– package.json: 应用包配置文件|– README.md: 应用描述说明的 readme 文件 4，示例代码：1）：HelloWorld.vue 12345678910111213141516171819202122&lt;template&gt; &lt;div id=&quot;demo&quot; class=&quot;element2&quot;&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; msg: &apos;Hello Vue Components&apos; &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt; .element2 &#123; color: red; font-size: 30px; &#125;&lt;/style&gt; 2）：App.vue: 12345678910111213141516171819202122&lt;template&gt; &lt;div id=&quot;&quot; class=&quot;element2&quot;&gt; &lt;img src=&quot;./assets/logo.png&quot; alt=&quot;&quot;&gt; &lt;HelloWorld/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import HelloWorld from &apos;./components/HelloWorld.vue&apos;export default &#123; components: &#123; HelloWorld &#125;&#125;&lt;/script&gt;&lt;style&gt; .element2 &#123; width: 400px; height: 400px; &#125;&lt;/style&gt; 3）：main.js 12345678910import Vue from &apos;vue&apos;import App from &apos;./App.vue&apos;/* eslint-disable no-new */new Vue(&#123; el: &apos;#app&apos;, components: &#123; App &#125;, template: &apos;&lt;App/&gt;&apos;&#125;) 5，效果图：6，项目的打包与发布1）打包： npm run build 2）使用静态服务器发布 ​ npm install -g serve ​ serve dist ​ 访问：http://localhost:5000 3）使用tomcat服务器发布 ​ 修改：webpack.prod.conf.js ​ output: ​ publicPath: ‘/xxxxx/‘ ​ ​ 重新打包： ​ npm run build ​ 修改dist文件夹为项目名称：xxxx ​ 将xxxx拷贝到tomcat的webapps目录下 ​ 访问：http://localhost:8080/xxxx 7，eslint1）说明 ​ eslint是一个代码规范检查工具 ​ 它定义了许多规则，一旦违背就会出现相应的提示 ​ 基本已经代替了之前的JSling 3）提供的校验 ​ 1）语法错误校验 2) 不重要或丢失的标点符号，如分号 3) 没法运行到的代码块（使用过 WebStorm 的童鞋应该了解） 4) 未被使用的参数提醒 5) 确保样式的统一规则，如 sass 或者 less 6) 检查变量的命名 4）规则的错误等级 ​ 1) 0：关闭规则。 2) 1：打开规则，并且作为一个警告（信息打印黄色字体） 3) 2：打开规则，并且作为一个错误（信息打印红色字体） 5）相关配置文件 ​ 1) .eslintrc.js : 全局规则配置文件 ‘rules’: ‘no-new’: 1 ​ 2) 在 js/vue 文件中修改局部规则 / eslint-disable no-new / new Vue( el: ‘body’, components: { App } ) 3) .eslintignore: 指令检查忽略的文件 .js .vue 8，组件的定义与使用1）Vue文件的组成 分为三个部分 ​ 模板页面： ​ ​ 页面模板 ​ ​ JS模块对象： ​ ` export default { ​ data() {return {}}, ​ methods: {}, ​ computed: {}, ​ components: {} } ` ​ 样式： ​ ​ 样式定义 ​ 2）基本使用 ​ ==引入组件== ​ ==映射成标签== ​ ==使用标签组件== ​ 示例代码： 12345678910111213141516171819202122&lt;template&gt; &lt;div id=&quot;&quot; class=&quot;element2&quot;&gt; &lt;img src=&quot;./assets/logo.png&quot; alt=&quot;&quot;&gt; &lt;HelloWorld/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import HelloWorld from &apos;./components/HelloWorld.vue&apos;export default &#123; components: &#123; HelloWorld &#125;&#125;&lt;/script&gt;&lt;style&gt; .element2 &#123; width: 400px; height: 400px; &#125;&lt;/style&gt; 3）标签名与标签属性名书写问题 ​ 写法一：一模一样 ​ 写法二：大写变小写中间使用 - 连接 9，组件之间的通信A）props：​ 1）在组件内声明所有的 props 2）方式一: 只指定名称 props: [‘name’, ‘age’, ‘setName’] 3）方式二: 指定名称和类型 props: { name: String, age: Number, ​ setNmae: Function } ​ 4） 方式三: 指定名称/类型/必要性/默认值 props: { name: { ​ type: String, ​ required: true, ​ default:xxx}, } ​ 5）注意： ​ 1) 此方式用于父组件向子组件传递数据 2) 所有标签属性都会成为组件对象的属性, 模板页面可以直接引用 3) 问题: a. 如果需要向非子后代传递数据必须多层逐层传递 b. 兄弟组件间也不能直接 props 通信, 必须借助父组件才可以 ​]]></content>
      <categories>
        <category>vue学习</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue01_核心]]></title>
    <url>%2F2018%2F12%2F05%2FVue01-%E6%A0%B8%E5%BF%83%2F</url>
    <content type="text"><![CDATA[Vue01_核心1，Vue的基本认识：1）一位华裔前Google工程师(尤雨溪)开发的前端js库 2）作用: 动态构建用户界面 3）特点： ​ *遵循MVVM模式 ​ *编码简洁, 体积小, 运行效率高, 移动/PC端开发 ​ *它本身只关注UI, 可以轻松引入vue插件和其它第三库开发项目 4）与其他前端JS框架的关联 ​ *借鉴angular的模板和数据绑定技术 ​ *借鉴react的组件化和虚拟DOM技术 5） vue包含一系列的扩展插件(库): * vue-cli: vue脚手架 * vue-resource(axios): ajax请求 * vue-router: 路由 * vuex: 状态管理 * vue-lazyload: 图片懒加载 * vue-scroller: 页面滑动相关 * mint-ui: 基于vue的组件库(移动端) * element-ui: 基于vue的组件库(PC端) 2，Vue的基本使用1）效果：一个输入框，里面输入数据，下面显示相应的数据。 2）步骤： 123456789&lt;!--1,引入vue.js2,创建Vue实例， 指定 el 选择器 data3，双向数据绑定： v-model4，显示数据： &#123;&#123;username&#125;&#125;5，理解 MVVM--&gt; 3）代码： 1234567891011121314 &lt;div id="mustang" &gt; &lt;input type="text" v-model="username"&gt; &lt;p&gt;&#123;&#123;username&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;script type="text/javascript" src="../js/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; const vm = new Vue(&#123; el: '#mustang', data: &#123; username: 'mustang' &#125; &#125;)&lt;/script&gt; 3，理解MVVM：4，模板语法1）模板的理解： ​ 动态的html页面 包含了一些Js语法代码：双大括号表达式和v-开头的指令 2）双大括号表达式： ` 语法： 1&#123;&#123;XXXXX&#125;&#125;` ​ 功能：向页面输出数据 ​ 可以调用对象的方法 3）指令一：强制数据绑定 ​ 功能：指定变化的属性值 ​ 完整写法： v-bind:xxx=&#39;yyy&#39; ​ 简洁语法： ：xxx=‘yyy’ 4）指令二：绑定事件监听 ​ 完整写法：v-on:keyup=’xxx’ v-on:keyup=’xxx(参数)’ ​ 简洁语法：@keyup=‘xxx’ @keyup.enter=&#39;xxx&#39; 5）示例代码： 1234567891011121314151617181920212223242526272829303132333435&lt;body&gt;&lt;div id="app"&gt; &lt;!--双大括号表达式的用法--&gt; &lt;p&gt;双大括号表达式的用法&lt;/p&gt; &lt;p&gt;&#123;&#123;username&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;username.toUpperCase()&#125;&#125;&lt;/p&gt; &lt;hr&gt; &lt;!--强制数据绑定的用法--&gt; &lt;p&gt;强制数据绑定的用法:将一个文本理解为一个表达式&lt;/p&gt; &lt;img :src="imgUrl" &gt; &lt;hr&gt; &lt;!--强制数据帮顶顶的用法--&gt; &lt;p&gt;强制数据绑定的用法:绑定监听&lt;/p&gt; &lt;button @click="hello"&gt;点击弹出&lt;/button&gt; &lt;button @click="test('带参数的 Mustang')"&gt;点击弹出&lt;/button&gt;&lt;/div&gt;&lt;script type="text/javascript" src="../js/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; const vm = new Vue(&#123; el: '#app', data: &#123; username: 'Mustang', imgUrl: 'http://img1.imgtn.bdimg.com/it/u=4016276316,619558019&amp;fm=26&amp;gp=0.jpg' &#125;, methods: &#123; hello()&#123; alert('Hello Mustang') &#125;, test(content)&#123; alert(content) &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt; 5，计算属性和监视1）计算属性： 在computed属性对象中定义计算属性的方法 ​ 1在页面中使用 `&#123;&#123;方法名&#125;&#125;`来显示计算的结果 2） 监视属性： ​ 通过vm对象的$watch()或者watch配置来监视指定的属性 ​ 当属性变化时，回调函数会自动调用，在函数内部进行计算 3）计算属性高级： 通过getter/setter实现对属性数据的监视和显示 ​ 计算属性存在缓存，多次读取只进行一次getter计算 4）示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;body&gt;&lt;div id="demo"&gt; 姓: &lt;input type="text" placeholder="First Name" v-model="firstName"&gt;&lt;br&gt; 名: &lt;input type="text" placeholder="Last Name" v-model="lastName"&gt;&lt;br&gt; &lt;!--fullName1是根据fistName和lastName计算产生--&gt; 姓名1(单向): &lt;input type="text" placeholder="Full Name1" v-model="fullName1"&gt;&lt;br&gt; 姓名2(单向): &lt;input type="text" placeholder="Full Name2" v-model="fullName2"&gt;&lt;br&gt; 姓名3(双向): &lt;input type="text" placeholder="Full Name3" v-model="fullName3"&gt;&lt;br&gt;&lt;/div&gt;&lt;script type="text/javascript" src="../js/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; const vm = new Vue(&#123; el: '#demo', data: &#123; firstName: 'wx', lastName: 'lt', fullName2: '' &#125;, computed: &#123; fullName1()&#123; return this.firstName+ '--'+this.lastName &#125;, fullName3: &#123; //// 当获取当前属性值时自动调用, 将返回值(根据相关的其它属性数据)作为属性值 get()&#123; return this.firstName+ " " + this.lastName &#125;, // 当属性值发生了改变时自动调用, 监视当前属性值变化, 同步更新相关的其它属性值 set(value)&#123; const names = value.split(' ') this.firstName = names[0] this.lastName = names[1] &#125; &#125; &#125;, watch: &#123; firstName: function (value) &#123; this.fullName2 = value + '-'+this.lastName &#125;, lastName: function (value) &#123; this.fullName2 = this.firstName + '-'+value &#125; &#125;, &#125;)&lt;/script&gt;&lt;/body&gt; 6，class绑定和style绑定1）理解： ​ 在应用界面中，某些元素的样式是变化的 ​ class绑定和style绑定就是实现动态样式的技术 2）class绑定： ​ ：class=“xxx” ​ 表达式是字符串：‘aClass’ ` 1表达式是对象： &#123;aClass：isA，bClass: isB&#125;` 3）style绑定： 123` ：style=“&#123;color: activeColor, fontSize: fontSize&#125;”`` activeColor和fontSize是data里面的属性` 4）示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;class,style绑定&lt;/title&gt; &lt;style&gt; .aClass &#123; color: red; &#125; .bClass &#123; color: blue; &#125; .cClass &#123; font-size: 30px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="demo"&gt; &lt;h2&gt;class绑定：&lt;/h2&gt; &lt;p :class="aClass" class="cClass"&gt;xxx是字符串&lt;/p&gt; &lt;p :class="&#123;aClass: isAClass, bClass: isBClass&#125;"&gt;xxx是对象&lt;/p&gt; &lt;h2&gt;style绑定：&lt;/h2&gt; &lt;p :style="&#123;color: activeColor, &#125;"&gt;显示style绑定的效果啦&lt;/p&gt; &lt;button @click="update"&gt;更新&lt;/button&gt; &lt;/div&gt;&lt;script type="text/javascript" src="../js/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; const vm = new Vue(&#123; el: '#demo', data: &#123; aClass: 'aClass', isAClass: true, isBClass: false, activeColor: 'red', size: '30px' &#125;, methods: &#123; update()&#123; this.aClass = 'bClass' this.isAClass = false this.isBClass = true &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt; 7，条件渲染指令1）v-if与v-else 2）v-show 3）示例代码： 123456789101112131415161718&lt;body&gt;&lt;div id="demo" &gt; &lt;p v-if="ok"&gt;失败&lt;/p&gt; &lt;p v-else&gt;成功&lt;/p&gt; &lt;p v-show="!ok"&gt;哈哈成功&lt;/p&gt; &lt;p v-show="ok"&gt;呜呜失败&lt;/p&gt; &lt;button @click="ok=!ok"&gt;切换&lt;/button&gt;&lt;/div&gt;&lt;script type="text/javascript" src="../js/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; const vm = new Vue(&#123; el: '#demo', data: &#123; ok: false, &#125; &#125;)&lt;/script&gt;&lt;/body&gt; 8，列表渲染：1) 列表显示指令 数组: v-for / index 对象: v-for / key2) 列表的更新显示 删除 item 替换 item3) 列表的高级处理 列表过滤 列表排序 4）示例代码： 使用v-for遍历数组和对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;body&gt;&lt;div id="demo"&gt; &lt;!--v-for遍历数组--&gt; &lt;ul&gt; &lt;li v-for="(person,index) in persons" :key="index"&gt; &#123;&#123;index&#125;&#125;---&#123;&#123;person.name&#125;&#125;---&#123;&#123;person.age&#125;&#125; ---&lt;button @click="deletePerson(index)"&gt;删除&lt;/button&gt; ---&lt;button @click="updatePerson(index,&#123;name:'love',age:99&#125;)"&gt;更新&lt;/button&gt; &lt;/li&gt; &lt;/ul&gt; &lt;!--v-for遍历对象，不怎么常用--&gt; &lt;ul&gt; &lt;li v-for="(value,key) in persons[1]"&gt;&#123;&#123;key&#125;&#125;---&#123;&#123;value&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;!--添加person--&gt; &lt;button @click="addPerson(&#123;name:'zhangsan',age:66&#125;)"&gt;添加&lt;/button&gt;&lt;/div&gt;&lt;script type="text/javascript" src="../js/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; const vm = new Vue(&#123; el: '#demo', data: &#123; persons: [ &#123;name:'wx',age:22&#125;, &#123;name:'lt',age:23&#125;, &#123;name:'jack',age:25&#125;, &#123;name:'rose',age:24&#125; ] &#125;, methods: &#123; deletePerson(index) &#123; this.persons.splice(index,1) &#125;, updatePerson(index,newPerson)&#123; this.persons.splice(index,1,newPerson) &#125;, addPerson(addPerson)&#123; this.persons.push(addPerson) &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt; 列表的过滤和排序功能： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;body&gt;&lt;div id="demo" &gt; &lt;input type="text" v-model="searchName"&gt; &lt;ul&gt; &lt;li v-for="(p, index) in filterPersons" :key="index"&gt; &#123;&#123;index&#125;&#125;---&#123;&#123;p.name&#125;&#125;---&#123;&#123;p.age&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;div&gt; &lt;button @click="setOrderType(2)"&gt;年龄升序&lt;/button&gt; &lt;button @click="setOrderType(1)"&gt;年龄降序&lt;/button&gt; &lt;button @click="setOrderType(0)"&gt;原本顺序&lt;/button&gt; &lt;/div&gt;&lt;/div&gt;&lt;script type="text/javascript" src="../js/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; const vm = new Vue(&#123; el: '#demo', data: &#123; searchName: '', orderType: '0',//0代表不排序，1代表升序，2代表降序 persons:[ &#123;name:'wx',age:22&#125;, &#123;name:'lt',age:23&#125;, &#123;name:'jack',age:24&#125;, &#123;name:'rose',age:25&#125; ] &#125;, computed: &#123; filterPersons()&#123; const persons = this.persons const searchName = this.searchName const orderType = this.orderType let filterPersons filterPersons = persons.filter(person =&gt; person.name.indexOf(searchName)!==-1) if(orderType !== 0)&#123; filterPersons.sort(function (p1, p2) &#123; if(orderType === 1)&#123; return p2.age - p1.age &#125;else&#123; return p1.age - p2.age &#125; &#125;) &#125; return filterPersons &#125; &#125;, methods: &#123; setOrderType(orderType)&#123; this.orderType = orderType &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt; 8，事件处理1）绑定监听 ​ ：xxx=“fun” ​ @xxx=“fun” ​ @xxx=“fun(参数)” ​ 默认事件形参：event ​ 隐含属性对象：$event 2）事件修饰符： ​ .prevent:组织事件的默认行为 event.preventDefault() ​ .stop:停止事件冒泡 event.stopPropaggation() 3）按键修饰符： ​ .keycode:操作的是某个keycode的值得键 ​ .keyName：操作的是某个按键名的键 4）示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;body&gt;&lt;div id="demo" class="element2"&gt; &lt;h1&gt;绑定监听&lt;/h1&gt; &lt;button @click="test1"&gt;test1&lt;/button&gt; &lt;button @click="test2('abc')"&gt;test2&lt;/button&gt; &lt;button @click="test3('abc',$event)"&gt;test3&lt;/button&gt; &lt;h1&gt;事件修饰符&lt;/h1&gt; &lt;a href="http://www.baidu.com" @click.prevent="test4"&gt;百度一下&lt;/a&gt; &lt;div style="width: 200px;height: 200px;background: red" @click="test5"&gt; &lt;div style="width: 100px;height: 100px;background: blue" @click.stop="test6"&gt;&lt;/div&gt; &lt;/div&gt; &lt;h1&gt;按键修饰符&lt;/h1&gt; &lt;input type="text" @keyup.13="test7"&gt; &lt;input type="text" @keyup.enter="test7"&gt;&lt;/div&gt;&lt;script type="text/javascript" src="../js/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; const vm = new Vue(&#123; el: '#demo', data: &#123; &#125;, methods: &#123; test1(event)&#123; alert(event.target.innerHTML) &#125;, test2(message)&#123; alert(message) &#125;, test3(message,event)&#123; alert(message + event.target.textContent) &#125;, test4 () &#123; alert('点击了链接') &#125;, test5 () &#123; alert('out') &#125;, test6 () &#123; alert('inner') &#125;, test7 (event) &#123; alert(event.target.value) &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt; 9，表单输入绑定1）使用v-model对表单数据自动收集 ​ text/textarea ​ checkbox ​ radio ​ select 2）示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;body&gt;&lt;div id="demo" class="element2"&gt; &lt;form action="/xxx" @submit.prevent="handleSubmit"&gt; 用户名：&lt;input type="text" v-model="username"&gt; &lt;br&gt; 密码：&lt;input type="text" v-model="password"&gt; &lt;br&gt; &lt;span&gt;性别: &lt;/span&gt; &lt;label for="male"&gt;男&lt;/label&gt; &lt;input type="radio" value="男" id="male" v-model="sex"&gt; &lt;label for="female"&gt;女&lt;/label&gt; &lt;input type="radio" value="女" id="female" v-model="sex"&gt; &lt;br&gt; &lt;span&gt;爱好&lt;/span&gt; &lt;input type="checkbox" id="basket" value="basket" v-model="hobbys"&gt; &lt;label for="basket"&gt;篮球&lt;/label&gt; &lt;input type="checkbox" id="foot" value="foot" v-model="hobbys"&gt; &lt;label for="foot"&gt;足球&lt;/label&gt; &lt;input type="checkbox" id="pingpang" value="pingpang" v-model="hobbys"&gt; &lt;label for="pingpang"&gt;乒乓&lt;/label&gt;&lt;br&gt; &lt;span&gt;城市&lt;/span&gt; &lt;select v-modle="cityId"&gt; &lt;option value=""&gt;未选择&lt;/option&gt; &lt;option v-for="(city,index) in allCitys" :key="city.id" :value="city.id"&gt;&#123;&#123;city.name&#125;&#125;&lt;/option&gt; &lt;/select&gt; &lt;br&gt; &lt;span&gt;介绍: &lt;/span&gt; &lt;textarea rows="10" v-model="info" v-model="content"&gt;&lt;/textarea&gt;&lt;br&gt;&lt;br&gt; &lt;input type="submit" value="注册"&gt; &lt;/form&gt;&lt;/div&gt;&lt;script type="text/javascript" src="../js/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; const vm = new Vue(&#123; el: '#demo', data: &#123; username: '', password: '', content: 'hello word', sex: '男', hobbys: ['basket'], allCitys: [ &#123;id: 1, name: '北京'&#125;, &#123;id: 2, name: '内蒙古'&#125;, &#123;id: 3, name: '黑龙江'&#125;, ], cityId: 2, &#125;, methods: &#123; handleSubmit () &#123; alert('提交注册的ajax请求') &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt; 10，Vue实例生命周期1）流程图： 2）Vue生命周期分析： 初始化显示： ​ beforeCreate（） created() beforeMount mounted() 更新状态： ​ beforeUpdate() updated() 销毁Vue实例： ​ beforeDestory destoryed 3）常用的生命周期方法 ​ created和mounted：发送ajax请求，启动定时器等异步任务 ​ beforeDestoryed:收尾工作，比如清除定时器 4）示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;body&gt;&lt;div id="demo" class="element2"&gt; &lt;button @click="destroyVue"&gt;destory vue&lt;/button&gt; &lt;p v-show="isShow"&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script type="text/javascript" src="../js/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; const vm = new Vue(&#123; el: '#demo', data: &#123; isShow: 'true', message: '普元信息技术股份有限公司' &#125;, methods: &#123; destroyVue () &#123; this.$destroy() &#125; &#125;, beforeCreate()&#123; console.log('beforeCreate......') &#125;, created()&#123; console.log('created.......') &#125;, beforeMount()&#123; console.log('beforeMount.....') &#125;, mounted()&#123; console.log('mount.......') this.intervalId = setInterval(() =&gt; &#123; console.log('-----') this.isShow = !this.isShow &#125;, 500) &#125;, beforeUpdate()&#123; console.log('beforeUpdate.....') &#125;, updated()&#123; console.log('updated.....') &#125;, beforeDestory()&#123; console.log('beforeDestory.....') clearInterval(this.intervalId) &#125;, destoryed()&#123; console.log('destoryed......') &#125; &#125;)&lt;/script&gt;&lt;/body&gt; 11，过渡动画1）操作css的transition和animation 2）vue会给特定的元素添加或者移除class 3）过渡的相关类名： ​ .xxx-enter-active 指定显示的transition ​ .xxx-leave-active 指定隐藏的transition ​ .xxx-enter 指定隐藏的样式 ​ .xxx-leave-to 指定隐藏的样式 4）基本过渡动画的步骤及示例代码： ​ 在目标元素外包裹==&lt;transition name=&quot;xxxx&quot;&gt; &lt;/transition&gt;== ​ 指定过渡样式： transition ​ 指定隐藏时的样式：opacity: 0/其他 5）示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;过度动画&lt;/title&gt; &lt;style&gt; /*指定过渡样式*/ .fade-enter-active, .fade-leave-active&#123; transition: opacity 1s; &#125; /*指定隐藏时的样式*/ .fade-enter, .fade-leave-to&#123; opacity: 0; &#125; /*指定demo2的显示样式*/ .move-enter-active&#123; transition: all 1s; &#125; .move-leave-active&#123; transition: all 3s; &#125; /*指定demo2的隐藏样式*/ .move-enter, .move-leave-to&#123; opacity: 0; transform: translateX(25px); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="demo" class="element2"&gt; &lt;button @click="isShow=!isShow"&gt;Toggle&lt;/button&gt; &lt;transition name="fade"&gt; &lt;p v-show="isShow"&gt;Hello World&lt;/p&gt; &lt;/transition&gt; &lt;hr&gt;&lt;/div&gt;&lt;div id="demo2" class="element2"&gt; &lt;button @click="isShow=!isShow"&gt;Toggle&lt;/button&gt; &lt;transition name="move"&gt; &lt;p v-show="isShow"&gt;Hello World&lt;/p&gt; &lt;/transition&gt; &lt;hr&gt;&lt;/div&gt;&lt;script type="text/javascript" src="../js/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; const vm = new Vue(&#123; el: '#demo', data: &#123; isShow: 'true' &#125; &#125;) const vm2 = new Vue(&#123; el: '#demo2', data: &#123; isShow: 'true' &#125; &#125;)&lt;/script&gt;&lt;/body&gt; 12，过滤器：1）效果图： 2）理解过滤器： ​ 对要显示的数据进行格式化再进行显示 ​ 没有改变原来的数据，但是产生新的数据 3）定义过滤器： ` 12345Vue.filter(date,function()&#123;`` return newValue``&#125;)` 4）使用过滤器： ` 12&lt;p&gt;&#123;&#123; time | filterName &#125;&#125;&lt;/p&gt;`&lt;p&gt;&#123;&#123; time | filterName(&apos;YYYY-MM-DD&apos;) &#125;&#125;&lt;/p&gt;指定显示的样式 5）示例代码： 12345678910111213141516171819202122&lt;body&gt;&lt;div id="demo" class="element2"&gt; &lt;h1&gt;日期的格式化&lt;/h1&gt; &lt;p&gt;&#123;&#123;time&#125;&#125;&lt;/p&gt; &lt;p&gt;完整版 &#123;&#123;time | timeString &#125;&#125;&lt;/p&gt; &lt;p&gt;年月日 &#123;&#123;time | timeString('YYYY-MM-DD')&#125;&#125;&lt;/p&gt; &lt;p&gt;时分秒 &#123;&#123;time | timeString('HH:mm:ss')&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script type="text/javascript" src="../js/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="https://cdn.bootcss.com/moment.js/2.22.1/moment.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; Vue.filter('timeString',function (value,format) &#123; return moment(value).format(format || 'YYYY-MM-DD HH:mm:ss') &#125;) const vm = new Vue(&#123; el: '#demo', data: &#123; time: new Date() &#125; &#125;)&lt;/script&gt;&lt;/body&gt; 13，Vue常用内置指令和自定义指令1）常用内置指令： ` 123456789101112131415161718192021v-if:如果为 true, 当前标签才会输出到页面`` v-else:如果为 false, 当前标签才会输出到页面`` v-text:更新元素的 textContent`` v-html:更新元素的 innerHTML`` v-model:双向数据绑定`` v-show:通过控制 display 样式来控制显示/隐藏`` v-on:绑定事件监听, 一般简写为@`` v-for:遍历数组/对象`` v-bind:强制绑定解析表达式, 可以省略 v-bind`` ref:指定唯一标识, vue 对象通过$els 属性访问这个元素对象`` v-cloak:防止闪现, 与 css 配合: [v-cloak] &#123; display: none &#125;` 2）示例代码： 12345678910111213141516171819202122&lt;body&gt;&lt;div id="demo" class="element2"&gt; &lt;p v-text="msg"&gt;&lt;/p&gt; &lt;p v-html="msg"&gt;&lt;/p&gt; &lt;p ref="content"&gt;www.wenxin.wiki&lt;/p&gt; &lt;button @click="hint"&gt;提示&lt;/button&gt;&lt;/div&gt;&lt;script type="text/javascript" src="../js/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; const vm = new Vue(&#123; el: '#demo', data: &#123; msg: 'www.baidu.com' &#125;, methods: &#123; hint()&#123; alert(this.$refs.content.innerHTML) &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt; 3）自定义指令： ​` 12345678910111213141516171819 注册全局指令：`` Vue.directive(&apos;指令名不带v-&apos;,function(el,binding)&#123;`` el.innerHTML = binding.value.toupperCase()`` &#125;)`` 注册局部指令：`` directives:&#123;`` &apos;指令名不带v-&apos;(el,binding)&#123;`` el.ijnnerHtml = binding,value.toLowerCase()`` &#125;`` &#125;` 4）示例代码： 123456789101112131415161718192021222324252627282930313233343536&lt;body&gt;&lt;div id="demo1" class="element2"&gt; &lt;p v-upper-text="msg"&gt;&lt;/p&gt; &lt;p v-lower-text="msg"&gt;&lt;/p&gt;&lt;/div&gt;&lt;div id="demo2" class="element2"&gt; &lt;p v-upper-text="msg"&gt;&lt;/p&gt; &lt;p v-lower-text="msg"&gt;&lt;/p&gt;&lt;/div&gt;&lt;script type="text/javascript" src="../js/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; Vue.directive('upper-text',function (el,binding) &#123; el.innerHTML = binding.value.toUpperCase() &#125;) Vue.directive('lower-text',function (el,binding) &#123; el.innerHTML = binding.value.toLowerCase() &#125;) const vm = new Vue(&#123; el: '#demo1', data: &#123; msg: 'NBA I Love This Game' &#125;, &#125;) const vm2 = new Vue(&#123; el: '#demo2', data: &#123; msg: 'Just Do It' &#125;, directives: &#123; 'upper-text'(el,binding)&#123; el.innerHTML = binding.value.toUpperCase() &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt; ###]]></content>
      <categories>
        <category>vue学习</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ansible10_roles详细介绍]]></title>
    <url>%2F2018%2F12%2F04%2FAnsible10-roles%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[Ansible10_roles详细介绍1,Roles:角色ansible自1.2版本引入的新特性，用于层次性，结构化的组织playbook，角色能够根据层次性结构自动转载变量文件 tasks以及handlers等，要使用角色只需在playbook中使用include指令即可，简单来讲，角色就是通过分别将变量，文件 任务，模板以及处理器放置于单独的目录中，并且可以快捷的include他们的一种机制，角色一般用于基于主机构建服务的 场景中，但是也可以用于构建守护进程等场景中。 复杂场景：建议使用roles，代码的复用度高 2，Roles的目录结构每个角色，以特定的层级目录结构进行组织 roles目录机构：​ playbook.yml ​ roles/ ​ project/ ​ tasks:定义task，role的基本元素，至少包含一个名为main.yml的文件，其他文件在此文件中include包含 ​ files:存放有copy或者script模块等调用的文件 ​ vars:不常用，定义变量，至少有一个名为main.yml文件。 ​ default:不常用，设定默认变量时，使用此目录中的main.yml文件 ​ templates:template模块查找说需要的模板文件的目录 handlers:至少有一个名为main.yml文件，其他文件用include包含 ​ meta:不常用，定义当前角色的特殊设定，及依赖关系，至少包含main.yml文件 3，角色应用的综合示例：以http服务器为例1，mkdir roles 2，mkdir app 3，mkdir tasks template vars handlers files 4，tree可以查看目录结构 tasks（任务）： 5，创建组：group 组名：app 系统组： system=yes gid=123 6，创建用户：user 用户名：app 将用户添加到组中，系统用户， shell=/sbin/nologin 7，安装包：yum 包：httpd 8，拷贝一些模板文件：/etc/httpd/conf/http.conf 复制到 /templates下改名为 http.conf.j2 ​ 修改问价内容，该Listen为 该user为 ​ 该group为 9，准备变量文件 /var/main.yml ——–username: app groupname: app 10,编写template.yml任务， src dest 11，添加 handlers和 notify 12，启动服务 13，重启服务]]></content>
      <categories>
        <category>Ansible学习</category>
      </categories>
      <tags>
        <tag>Ansible</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ansible09_Playbook详细介绍]]></title>
    <url>%2F2018%2F12%2F03%2FAnsible09-Playbook%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[Ansible09_Playbook详细介绍一：playbook简介：1,playbook是由一个或者多个play组成的列表 2，play的主要作用在于将事先归并为一组的主机装扮成事先通过ansible的task定义好的角色 ​ 从根本上讲，所谓task无非是调用ansible的一个module，将多个play组织在一个playbook中， ​ 可以让他们联同起来按事先编排的机制协同工作。 3，playbook采用的是yml语言编写 二，playbook的工作流程： 1,流程解析： 我们编写了一个playbook，然后去调用playbook，最终也是用ansible命令执行的，去调用一个一个的play， 当然每个play都有自己的任务，那么任务的执行本质来讲就是来调用模块，模块在执行的时候，要看看是针对 主机清单中的哪些主机执行的 2，如果说ansible的单个模块相当于linux中的单行命令，那么playbook就相当于脚本的概念，将许多命令放在 脚本里面，按照自己定义的顺序执行。 三playbook的核心元素概览1，hosts：执行的远程主机列表 2，tasks：任务集 3，varniables：内置变量或者自定义变量在playbook中调用 4，templates：模板，可替换模板文件中的变量，并实现一些简单逻辑的文件 5，Handlers:和notify配合使用，有特定的条件触发的操作，满足条件执行，否则就不执行 6，tags：标签，执行某任务的执行，用于选择playbook中部分代码，ansible具有幂等性，因此会自动跳过 ​ 没有变化的部分。 eg： ansible-playbook -t tagname useradd.yml 四：playbook的基础组件1,hosts: ​ playbook中每一个play的目的都是为了让某一个或者某些主机以某个指定的用户身份执行任务， ​ hosts用于执行要执行的指定任务的主机，事先电仪在主机清单中。 形式： ​ 192.168.10.129或者192.168.10.* ​ webservers或者webservers:dbservers或者webservers&amp;appservers或者webservers:! appservers 2,remote_user: ​ 可用于host和task中，也可以通过指定其sudo的方式在远程主机上执行任务 3，tasks：任务列表 使用ignore-errors来忽略错误信息。 上图是一个基本的playbook的结构。 五，运行playbook1，方式： ​ ansible-playbook xxxx.yml 2,常见选项： ​ –check 或者 -C : 只检查语法，不真正的运行 ​ –list-hosts:列出运行任务的主机 ​ –limit 主机列表：只针对主机列表中的主机执行 -v：显示过程 --v显示详细的过程 ​ 示例： ​ ansible-playbookl file.yml -C ​ ansible-playbook file,.yml ​ ansible-playbook file.yml –limit webservers 六：handlers和notify结合使用触发条件1，handlers：相当于一个触发器 ​ 是task列表，这些task于之前task本质相同，用于关注的资源发生变化时，才会执行一定的操作 2，notify：此action可以用于在每个play的最后触发，这样可以避免多次有改变发生时，每次都执行的 ​ 操作，仅在所有的变化发生完成后一次性执行指定操作，在notify中列出的操作成为handler，即 ​ notify中调用handler中定义的操作。 七，变量的使用：1， 变量名：仅能由字母，数字，下划线组成，且只能以字母开头。 2，变量的来源： ​ 1，ansible的setup模块中，这些变量定义了本机的系统信息。 ​ 可以使用 ansible webservers -m setup -a ‘filter=address‘用过滤器查找相关的变量 ​ 2，在/etc/ansible/hosts中定义 ​ 普通变量：主机组中主机单独定义，优先级高于公共变量 ​ 公共变量：针对主机组中所有主机定义同一变量 ​ 3，通过命令行指定变量，优先级最高 ansible-playbook -e varname=value ​ 4，在playbook中定义变量： ​ vars: ​ var1: value1 ​ var2: value2 ​ 5，在角色中定义 3，变量的调用方式： ​ 通过 来调用变量，变量名前后加空格。 4，变量的优先级： ​ -e &gt; playbok &gt; 主机清单 定义的变量 八：模板templates的使用​ 1，根据西永的配置文件状态，生成对用的文件 ​ 2，文本文件嵌套有Jinja2语言，使用字面量，有如下形式： ​ 字符串：使用单引号或者双引号 ​ 数字：整数，浮点型 ​ 列表：[item1,item2,item…] ​ 元组:(item1,item2,item…) ​ 字典：{key:value,key2:value…} ​ 布尔：true、false ​ 算术运算： + - * // / % ​ 比较：== != &gt; &lt; &gt;= &lt;= ​ 逻辑： and or not ​ for if when ​ 3,when:条件测试：如果需要根据变量facts，或者此前任务的执行结果来作为某task执行与否的前提时，需要用到 ​ 通过when语句实现在task中，jinja2语法格式。在task后添加when子句即可使用条件测试 ​ eg： - name: ‘shut down RedHat flavored systemc’ ​ command: /sbin/shutdown -h now ​ when: ansible -os_family == “RedHat” ​ 4,迭代：with_items ​ 当有需要重复性的执行的任务时，可以使用迭代机制 ​ 对迭代项目的应用，固定变量名为item，要在task中使用with_items给定要迭代的元素列表 ​ ​ eg:需求：创建三个用户将用户加到刚刚创建的组中。 ​ ​ ​]]></content>
      <categories>
        <category>Ansible学习</category>
      </categories>
      <tags>
        <tag>Ansible</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ansible08_ansible-console介绍]]></title>
    <url>%2F2018%2F12%2F03%2FAnsible08-ansible-console%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[Ansible08_ansible-console介绍1.ansible2.0新增，可以交互执行命令2,root@test(2)[f:10] $解析：root为当前的执行用户，test为当前操作的主机组 (2)为当前组的主机数量，[f:10] 10代表并发数 3，设置并发数： eg：forks n4,切换组： cd 主机组 eg：cd webservers5，列出所有的内置命令 ? 或者help6,列出当前组的主机列表：list6，示例：root@all(2)[f:5]$ listroot@all(2)[f:5]$ cd webserversroot@all(2)[f:5]$ yum name=httpd state=presentroot@all(2)[f:5]$ service name=httpd state=started]]></content>
      <categories>
        <category>Ansible学习</category>
      </categories>
      <tags>
        <tag>Ansible</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ansible07_Ansible-vault介绍]]></title>
    <url>%2F2018%2F12%2F03%2FAnsible07-Ansible-vault%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[Ansible07_Ansible-vault介绍1，功能：管理加密解密yml文件的2，相关命令：加密：ansible-vault encrypt hello.yml解密：ansible-vault decrypt hello.yml查看：ansible-vault view hello.yml编辑加密文件：ansible-vault edithello.yml修改口令：ansible-vault rekey hello.yml创建新文件：ansible-vault create hello.yml]]></content>
      <categories>
        <category>Ansible学习</category>
      </categories>
      <tags>
        <tag>Ansible</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ansible06_galaxy介绍]]></title>
    <url>%2F2018%2F12%2F03%2FAnsible06-galaxy%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[Ansible06_galaxy介绍1，ansible-falaxy：链接ansible网络的一个工具 2，链接https://galaxy.ansible.com 下载对应的roles 3，安装： ​ ansible-galaxy install geerlingguy.redis 下载之后会提示下载到哪个目录了在最后一行 4，删除galaxy： ansible-galaxy remove geerlingguy.redis 总结：可以联网下载自己所需的角色，下载之后可以改成自己能用的]]></content>
      <categories>
        <category>Ansible学习</category>
      </categories>
      <tags>
        <tag>Ansible</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ansible05_常用模块详细介绍]]></title>
    <url>%2F2018%2F12%2F03%2FAnsible05-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[Ansible05_常用模块详细介绍首先介绍一下ansible命令的格式写法： ansible all -m command -a ‘ xxxxxxx ‘all：代表的是所有的被控端，all也可以替换成为部分被控端的组的名称 -m：指定要用哪个模块 command：默认模块，可以忽略不写 ‘xxxxx’：代表的是要执行的命令 比如： ls /data/ ‘df -h’ 查看分区利用率 注：Ansible所有的模块我们在使用的时候都可以通过 ansible-doc 模块名 来查询相应的用法1，Command模块：参数： ​ chdir：切换到某一个文件夹再执行命令 ​ creates：如果后该参数后面跟一个文件或者文件夹，如果存在，将不执行后面的命令 ​ removes：如果该参数和面跟一个文件或者文件夹，如果不存在，将不执行和面的命令 不支持的条件： 此命令不支持命令中带有 | $ 变量 &lt; &gt; &amp; 等等 得使用shell模块实现 2，Shell模块：参数： ​ 和command类似 eg： ​ ansible all -m shell -a ‘ps aux grep|nginx’ 3,Script:运行脚本的模块tips：在编写脚本的时候，应该遵循规范在第一行加上： #!/bin/basheg: echo hostname &gt; test.shchmod +x test.shansible all - m script -a ‘./test.sh’4.copy模块：从主控端复制文件到被控端ansible all -m copy -a ‘src=/root/test.sh dest=/tmp/test.sh backup=yes’ 参数：src:主控端的路径 ​ dest:要复制到被控端的文件路径 ​ backup=yes：将原来的文件做一个备份，如果目标存在先进行备份再复制 5，fetch模块：从被控端取文件到主控端与copy相反： 但是只能抓取被控端的一个文件，如果想抓取多个，将多个文件进行打包再fetch过来， 命令格式：抓取：ansible all -m ==fetch== -a ‘src=/root/log.tar.xz dest=/data/‘打包：ansible all -m shell -a ‘tar Jcf log.tar.xz /var/log/*.log’预览：tar tvf log.tar.xz6,File模块：设置文件的属性创建一个文件：ansible all -m file -a ‘path=/root/test owner=wx ==state=touch==’删除一个文件：ansible all -m file -a ‘path=/root/test ==state=absent’==创建一文件夹：ansible all -m file -a ‘path=/root/test ==state=directory==’复制文件到被控端：ansible all -m file -a ‘==src=/app/test/file dest=/app/test/file==’7,hostname模块:管理主机名eg: ansible 192.168.10.129 -m ==hostname== -a ‘==name===hostOne’8，Cron模块：计划任务先查询广播路径： which wall —&gt;/usr/bin/wall支持时间： minute hour day month weekday命令：创建名为name的任务 ：ansible all -m cron -a ‘minute=* job=”/usr/bin/wall” NBA Warning name=warningcron’禁用任务：ansible all -m cron -a ‘==disabled=true== job=”/usr/bin/wall NBA Warning” name=warningcron’启用任务：将上面的disabled改为false即可删除任务：ansible all -m cron -a ‘job=”/usr/bin/wall NBAWarning” name=warincron ==state=absent==’查看任务：crontab -e9,yum模块：管理包前提：被控端都有yum3，检查yum仓库/etc/yum.repos.d/base.repo 安装：ansible all -m yum -a ‘name=httpd’查看一已经安装的包：ansible all -m yum -a ‘list=installed’卸载包：ansible all -m yum -a ‘name=httpd ==state=absent==’查看是否卸载了：ansible all -m shell -a ‘rpm -q httpd’如果要安装多个包使用逗号隔开即可 yum更新缓存：update_cache=yes 10,service模块：管理服务state:代表状态，状态不同服务也不同 enabled:代表的是开机是否自启动 开启服务:ansible all -m service -a ‘name=httpd state=started enabled=yes’停止服务：ansible all -m service -a ‘name=httpd state=restarted’重启服务：ansible all -m service -a ‘name=httpd state=stopped’确认开机是否自启动了： systemctl is-enabled httpd确认是否启动了：systemctl status httpd11,user模块:管理用户创建一个用户：ansible all -m user -a ‘name=wenxin shell=/sbin/nologin system=yes groups=root uid=80’查看用户：ansible all -a ‘getent passwd wenxin’删除用户： ansible all -m user -a ‘name=wenixn state=absent’12.group模块：管理组创建组： ansible all -m group -a ‘name=nginx system=yes gid=82’验证：ansible all -m shel -a ‘getent group nginx’删除：ansible all =m group -a ‘name=nginx state=absent’13ping模块：检查主控端和被控端的连通性命令：ansible all -m ping14,总结：ansible中的模块有1000多个我只是学了常用的13个模块，如果想要学习新的模块可以到官网。平时在学习的过程中可以使用： ansible-doc -s 模块名 来看看这个模块怎么用。####]]></content>
      <categories>
        <category>Ansible学习</category>
      </categories>
      <tags>
        <tag>Ansible</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test2]]></title>
    <url>%2F2018%2F11%2F29%2Ftest2%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Ansible02_运维自动化之ansible]]></title>
    <url>%2F2018%2F11%2F27%2FAnsible02-%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96%E4%B9%8Bansible%2F</url>
    <content type="text"><![CDATA[Ansible02_配置文件及命令概览1,Ansible:一个主机控制多台主机这个主机被称为：主控端 被控制的多台主机称为：被控端 2，Ansible特性模块化：调用特定的模块完成特定的任务 基于Python语言实现 部署简单 安全：基于OpenSession 支持Playbook任务编排 幂等性：一个任务执行一遍和执行N遍的效果是一样的，不因重复发的执行带来意外的情况 无需代理，不依赖KPI 3，Ansible架构图： 4,Ansible的主要组成部分​ 1，PlayBooks:任务剧本，编排任务集的配置文件，由ansible顺序执行，通常是Json格式的yml文件 ​ 2，Inventory：管理主机清单 /etc./ansible/hosts ​ 3，Modules:Ansible执行命令的功能模块 ​ 4，plugins：模块功能的补充 ​ 5，API：供第三方程序调用的借口 ​ 6，Ansible：ansible的命令工具 5，Ansible的安装：​ yum install ansible 如果在执行ansible的命令时报错： ERROR! Unexpected Exception, this is probably a bug: (cryptography 0.8.2 (/usr/lib64/python2.7/site-packages), Requirement.parse(‘cryptography&gt;=1.1‘)) 解决方案： 删除列出的软件包，重新安装ansible即可 [root@kazihuo ~]# rpm -qa |grep python-crypto[root@kazihuo ~]# yum -y remove python-cryptography [root@kazihuo ~]# yum -y install ansible 6，Ansible相关配置文件：/etc/ansible/ansible.cfg：主配置文件 /etc/ansible/hosts：主机清单配置文件 ​ 风格： [webservers] ​ 192.168.10.128 ​ 192.168.10.129 或者 9 192.168.10.12[….] ​ 192.168.10.130 /etc/ansible/roles：存放角色目录 7.程序：/usr/bin/ansible：主程序，临时命令的执行工具 /usr/bin/ansible-doc：查看配置文档，模块功能查看工具 /usr/bin/ansible-galaxy：下载/上传代码 /usr/bin/ansible-playbook：定制自动化服务 /usr/bin/ansible-vault：文件加密工具 /usr/bin/ansible-console：基于console界面与用户交互的执行工具 8,Ansible配置文件 /etc/ansible/ansible.cfg#invengory=etc/ansible/hosts #主机列表配置文件#libraay=/usr/share/my-modules/ #库文件的存放目录#remote_tmp=$HOME/.ansible/tmp #临时py命令存放在远程主机目录#local_tmp=$HOME/.ansible/tmp #本机的临时命令执行目录#forks =5 #默认的并发数#sudo-user=root #默认的sudo用户#ask-sudo-pass=True #每次执行ansible命令是否询问ssh密码#ask-pass=True#remote-port=22#host-key-checking-False #检测对应服务器的Host-key建议取消注释9，Ansible系列命令：没有注解的后面会详细说。ansible ansible-doc：显示模块帮助 ​ ansible-doc [module] ansible-doc -a : 显示所有模块的文档 （不常用） ​ ansible-doc –list 列出所有的可用模块 eg: ​ ansible-doc -s ping ：-s的作用就是显示指定模块的playbook片段 ​ ansible-doc ping : 查看指定模块(ping)的帮助用法 ​ ansible-doc -l : 列出所有模块 ansible-playbook ​ 执行playbook的工具 ansible-vault ​ 用于playbook的加密解密作用 ansible-console ansible-galaxy ansible-pull]]></content>
      <categories>
        <category>Ansible学习</category>
      </categories>
      <tags>
        <tag>Ansible</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ansible03_配置基于key的验证]]></title>
    <url>%2F2018%2F11%2F27%2FAnsible03-%E9%85%8D%E7%BD%AE%E5%9F%BA%E4%BA%8Ekey%E7%9A%84%E9%AA%8C%E8%AF%81%2F</url>
    <content type="text"><![CDATA[Ansible03_配置基于key的验证0，ansible通过ssh实现配置管理，应用部署，任务执行等功能，建议配置ansible端基于秘钥认证的方式联系被管理的远程主机。1，在安装完成之后，我们到对应的hosts文件下去配置远程主机：/etc/ansible/hosts：主机清单配置文件 ​ 风格： [webservers] ​ 192.168.10.128 ​ 192.168.10.129 或者 192.168.10.12[….] ​ 192.168.10.130 2，配置完主机之后，接下来要与其他的主机建立连接，那么，如果按普通的方式，在链接的时候，需要对远程主机输入验证密码 也就是说在命令上加上 -k 这样未免也太过麻烦了。比如： ​ ansible webservers -m command -k -a ‘ ls /root ‘ 所以解决的方案就是来为每一台远程主机配置基于key的验证： 在终端输入以下命令： ​ 1，ssh-keygen ​ 2，ssh-copy-id 192.168.10.129 (有几个远程主机就加几个，重复执行即可)]]></content>
      <categories>
        <category>Ansible学习</category>
      </categories>
      <tags>
        <tag>Ansible</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ansible04_ansible命令执行过程及常用模块]]></title>
    <url>%2F2018%2F11%2F27%2FAnsible04-ansible%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[Ansible04_ansible命令执行过程1，ansible命令执行过程：​ 1，加载自己的配置文件，默认在目录 /etc/ansible/ansible.cfg ​ 2，加载自己的模块文件，如command ping 等等 ​ 3，通过ansible将模块或者命令生成对应的临时py文件，并且将该文件传输至被控端的 $用户， ​ /.ansible/tmp/ansible-tmp-数字/xxxxx.py文件 ​ 4，给文件进行 +x 加执行权限操作 ​ 5，执行并且返回结果 ​ 6，删除临时文件，然后退出 2，执行状态：​ 绿色：成功，不需要做改变的操作 ​ 黄色：成功，并且对目标主机进行了变更操作 ​ 红色：执行失败。]]></content>
      <categories>
        <category>Ansible学习</category>
      </categories>
      <tags>
        <tag>Ansible</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ansible01_运维自动化发展历程及技术应用]]></title>
    <url>%2F2018%2F11%2F27%2FAnsible01-%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B%E5%8F%8A%E6%8A%80%E6%9C%AF%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Ansible01_运维自动化发展历程及技术应用一，发展历程1，on-premises:本地部署（硬件，操作系统，软件，全部自己做） 2，IAAS（Infrastracfure as a service）：基础设施即服务 3，PAAS（PlatForm as a service）:平台即服务 4，SAAS(SoftWare as a service): 软件即服务 二，自动化运维应用场景1,文件传输 2，命令执行： 应用部署，配置管理，任务流编排 三，整体流程：开发环境–&gt;测试环境–&gt;发布环境–&gt;生产环境–&gt;灰度环境（新版本更新，只发布服务器中的几台） 灰度环境分为： 基于用户的灰度环境和基于地区的灰度环境 四：程序发布：1，预发布验证：新版本代码发布到服务器(未接入调度器) 2，程序发布：不能影响用户的体验，不能造成系统的崩溃 3，灰度发布 4，发布路径： ​ /webapp/old-1.1 ​ /webapp/diaodu——&gt;指向正在使用的版本 ​ /webapp/new-1.2 5，发布过程： ​ 在调度器上下线一批主机（标记为maintanance状态） ​ 关闭服务 ​ 部署新版本的应用程序 ​ 启动服务 ​ 在调度器上面启动这一批服务器 6，自动化灰度发布： 脚本发布平台]]></content>
      <categories>
        <category>Ansible学习</category>
      </categories>
      <tags>
        <tag>Ansible</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2F2018%2F11%2F26%2Ftest%2F</url>
    <content type="text"><![CDATA[test]]></content>
  </entry>
  <entry>
    <title><![CDATA[HEXO_github与自己域名绑定]]></title>
    <url>%2F2018%2F11%2F26%2FHEXO-github%E4%B8%8E%E8%87%AA%E5%B7%B1%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[HEXO_github与自己域名绑定1，首先登录阿里云，搜索域名或者在控制台找到域名。进入之后，首先查询你要申请的域名，如果查不到就表示可以注册。2，成功申请域名之后，将域名和Github绑定，Github的IP地址是192.30.252.153或192.30.252.154。所以我们在填写解析的时候，就解析这个地址。至于Github是怎么找到我们的仓库的，这个在CNAME设置。3，进入域名解析之后1，点击【新增解析】；依次填写相应内容。2，“记录类型”选择A；”主机记录”填写www；”解析线路”选择默认；3，“记录值”填写github提供的IP地址，192.30.252.153或192.30.252.154；4，“TTL”默认10分钟，自己可以另行设置也可；5，最后点击【保存】。6，域名成功解析之后，在你Github上面的仓库中创建CNAME，然后输入你申请域名的地址。然后你再输 入你的域名就可以访问Github博客了。4，如果后面上传博客出404错误原因是在上传博客时CNAME文件没有了。所以解决办法就是进入自己的github在自己的仓库中重新创建CNAME文件，并添加自己的域名。]]></content>
      <categories>
        <category>个人博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO_添加live2d看板动画]]></title>
    <url>%2F2018%2F11%2F26%2FHEXO-%E6%B7%BB%E5%8A%A0live2d%E7%9C%8B%E6%9D%BF%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[HEXO_添加live2d看板动画1,官网代码官网地址配置：https://www.npmjs.com/package/hexo-helper-live2d 2,按如下步骤执行1,首先检查博客主目录下面的 package.json里是否有&quot;hexo-helper-live2d&quot;: &quot;^3.0.3&quot;,依赖，有的话可以先卸载 使用命令：npm uninstall hexo-helper-live2d 之后再安装：npm install --save hexo-helper-live2d 2,下载各种动画model 地址： https://github.com/xiazeyu/live2d-widget-models.git 3,下载好之后将packages里的所有动画模板拷贝到博客的node_modules目录里 4,配置博客站点配置文件，_config.yml 1234567891011live2d: enable: true pluginModelPath: assets/ model: use: live2d-widget-model-epsilon2_1 #模板目录，在node_modules里 display: position: right width: 150 height: 300 mobile: show: false #是否在手机进行显示 5,开始部署: ​ hexo clean ​ hexo g -d 6,效果图：]]></content>
      <categories>
        <category>个人博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO_更换背景图片]]></title>
    <url>%2F2018%2F11%2F23%2FHEXO-%E6%9B%B4%E6%8D%A2%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[HEXO_更换背景图片1,背景图片来源 （可根据自己的喜好设置图片的url）2，修改背景样式打开文档下themes\next\source\css\ _custom\custom.styl文件，这个是Next故意留给用户自己个性化定制一些样式的文件，添加以下代码： body { background:url(https://source.unsplash.com/random/1600x900); background-repeat: repeat; background-attachment:fixed; background-position:50% 50%;}url可更换为自己喜欢的图片的地址。 repeat：是否重复出现 attachment：定义背景图片随滚动轴的移动方式 position：设置背景图像的起始位置。 3，效果图：]]></content>
      <categories>
        <category>个人博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO_添加站内搜索]]></title>
    <url>%2F2018%2F11%2F23%2FHEXO-%E6%B7%BB%E5%8A%A0%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[HEXO_添加站内搜索1,NexT主题支持集成 Swiftype、 微搜索、Local Search 和 Algolia。下面介绍Local Search的安装。2,安装 hexo-generator-search1npm install hexo-generator-search --save 3,安装 hexo-generator-searchdb1npm install hexo-generator-searchdb --save 4,编辑站点配置文件，添加以下内容 :12345search: path: search.xml field: post format: html limit: 10000 5,编辑主题配置文件，设置Local searchenable为ture123456789# Local search# Dependencies: https://github.com/flashlab/hexo-generator-searchlocal_search: enable: ture # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 6, 效果如下图所示：]]></content>
      <categories>
        <category>个人博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO_在文章底部增加版权信息]]></title>
    <url>%2F2018%2F11%2F23%2FHEXO-%E5%9C%A8%E6%96%87%E7%AB%A0%E5%BA%95%E9%83%A8%E5%A2%9E%E5%8A%A0%E7%89%88%E6%9D%83%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[HEXO_在文章底部增加版权信息1,在目录Blog/themes/next/layout/_macro/，添加文件 my-copyright.swig，内容如下：123456789101112131415161718192021222324252627282930&#123;% if page.copyright %&#125;&lt;div class=&quot;my_post_copyright&quot;&gt; &lt;script src=&quot;//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js&quot;&gt;&lt;/script&gt; &lt;!-- JS库 sweetalert 可修改路径 --&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/sweetalert/dist/sweetalert.min.js&quot;&gt;&lt;/script&gt; &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot;&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&lt;a href=&quot;/&quot; title=&quot;访问 &#123;&#123; theme.author &#125;&#125; 的个人博客&quot;&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format(&quot;YYYY年MM月DD日 - HH:MM&quot;) &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format(&quot;YYYY年MM月DD日 - HH:MM&quot;) &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot; title=&quot;&#123;&#123; page.title &#125;&#125;&quot;&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt; &lt;span class=&quot;copy-path&quot; title=&quot;点击复制文章链接&quot;&gt;&lt;i class=&quot;fa fa-clipboard&quot; data-clipboard-text=&quot;&#123;&#123; page.permalink &#125;&#125;&quot; aria-label=&quot;复制成功！&quot;&gt;&lt;/i&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;span&gt;许可协议:&lt;/span&gt;&lt;i class=&quot;fa fa-creative-commons&quot;&gt;&lt;/i&gt; &lt;a rel=&quot;license&quot; href=&quot;https://creativecommons.org/licenses/by-nc-nd/4.0/&quot; target=&quot;_blank&quot; title=&quot;Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)&quot;&gt;署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt; 转载请保留原文链接及作者。&lt;/p&gt; &lt;/div&gt;&lt;script&gt; var clipboard = new Clipboard(&apos;.fa-clipboard&apos;); $(&quot;.fa-clipboard&quot;).click(function()&#123; clipboard.on(&apos;success&apos;, function()&#123; swal(&#123; title: &quot;&quot;, text: &apos;复制成功&apos;, icon: &quot;success&quot;, showConfirmButton: true &#125;); &#125;); &#125;); &lt;/script&gt;&#123;% endif %&#125; 2,在目录Blog/themes/next/source/css/_common/components/post/下添加文件my-post-copyright.styl，添加以下代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445.my_post_copyright &#123; width: 85%; max-width: 45em; margin: 2.8em auto 0; padding: 0.5em 1.0em; border: 1px solid #d3d3d3; font-size: 0.93rem; line-height: 1.6em; word-break: break-all; background: rgba(255,255,255,0.4);&#125;.my_post_copyright p&#123;margin:0;&#125;.my_post_copyright span &#123; display: inline-block; width: 5.2em; color: #b5b5b5; font-weight: bold;&#125;.my_post_copyright .raw &#123; margin-left: 1em; width: 5em;&#125;.my_post_copyright a &#123; color: #808080; border-bottom:0;&#125;.my_post_copyright a:hover &#123; color: #a3d2a3; text-decoration: underline;&#125;.my_post_copyright:hover .fa-clipboard &#123; color: #000;&#125;.my_post_copyright .post-url:hover &#123; font-weight: normal;&#125;.my_post_copyright .copy-path &#123; margin-left: 1em; width: 1em; +mobile()&#123;display:none;&#125;&#125;.my_post_copyright .copy-path:hover &#123; color: #808080; cursor: pointer;&#125; 3,在Blog/themes/next/source/css/_common/components/post/添加文件my-post-copyright.styl，文件内容如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445.my_post_copyright &#123; width: 85%; max-width: 45em; margin: 2.8em auto 0; padding: 0.5em 1.0em; border: 1px solid #d3d3d3; font-size: 0.93rem; line-height: 1.6em; word-break: break-all; background: rgba(255,255,255,0.4);&#125;.my_post_copyright p&#123;margin:0;&#125;.my_post_copyright span &#123; display: inline-block; width: 5.2em; color: #b5b5b5; font-weight: bold;&#125;.my_post_copyright .raw &#123; margin-left: 1em; width: 5em;&#125;.my_post_copyright a &#123; color: #808080; border-bottom:0;&#125;.my_post_copyright a:hover &#123; color: #a3d2a3; text-decoration: underline;&#125;.my_post_copyright:hover .fa-clipboard &#123; color: #000;&#125;.my_post_copyright .post-url:hover &#123; font-weight: normal;&#125;.my_post_copyright .copy-path &#123; margin-left: 1em; width: 1em; +mobile()&#123;display:none;&#125;&#125;.my_post_copyright .copy-path:hover &#123; color: #808080; cursor: pointer;&#125; 4,修改Blog/themes/next/layout/_macro/post.swig，在如图位置添加以下代码：12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;my-copyright.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 5,在Blog/themes/next/source/css/_common/components/post/post.styl文件最后加入下面的代码：1@import &quot;my-post-copyright&quot; 6.在Markdown文章中加入copyright : ture：12345678910---title: Hexo-NexT主题配置date: 2018-01-20 20:41:08categories: Hexotags:- Hexo- NexTtop: 100copyright: ture--- 7,配置根目录下的_config.yml文件，配置为：123456# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://jackLovewx.github.io/ //你的网站地址root: /permalink: :year/:month/:day/:title/permalink_defaults: 8,效果图如下所示：]]></content>
      <categories>
        <category>个人博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO_添加侧栏推荐阅读]]></title>
    <url>%2F2018%2F11%2F23%2FHEXO-%E6%B7%BB%E5%8A%A0%E4%BE%A7%E6%A0%8F%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[HEXO_添加侧栏推荐阅读1,编辑主题配置文件，如下配置即可：12345678# Blog rollslinks_icon: linklinks_title: 推荐阅读#links_layout: blocklinks_layout: inlinelinks: HEXO个人博客初级搭建: https://jacklovewx.github.io/2018/11/20/HEXO%E5%88%9D%E7%BA%A7%E6%90%AD%E5%BB%BA/#more 百 度: http://www.baidu.com 2,效果图：]]></content>
      <categories>
        <category>个人博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO_添加底部桃心]]></title>
    <url>%2F2018%2F11%2F23%2FHEXO-%E6%B7%BB%E5%8A%A0%E5%BA%95%E9%83%A8%E6%A1%83%E5%BF%83%2F</url>
    <content type="text"><![CDATA[HEXO_添加底部桃心1,打开Blog/themes/next/layout/_partials/footer.swig搜索with-love，在fontawesom找到你喜欢的图标，在如下位置替换即可： 2,效果如下图所示：]]></content>
      <categories>
        <category>个人博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO_添加DaoVoice在线联系]]></title>
    <url>%2F2018%2F11%2F23%2FHEXO-%E6%B7%BB%E5%8A%A0DaoVoice%E5%9C%A8%E7%BA%BF%E8%81%94%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[HEXO_添加DaoVoice在线联系1,首先到DaoVoice注册账号，登录成过后，进入到后台管理，点击应用设置——&gt;安装到网站查看安装代码和AppID。 2,将安装代码添加到blog/themes/next/layout/_partials/head.swig中：123456789&#123;% if theme.daovoice %&#125; &lt;script&gt; (function(i,s,o,g,r,a,m)&#123;i[&quot;DaoVoiceObject&quot;]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset=&quot;utf-8&quot;;m.parentNode.insertBefore(a,m)&#125;)(window,document,&quot;script&quot;,(&apos;https:&apos; == document.location.protocol ? &apos;https:&apos; : &apos;http:&apos;) + &quot;//widget.daovoice.io/widget/0f81ff2f.js&quot;,&quot;daovoice&quot;) daovoice(&apos;init&apos;, &#123; app_id: &quot;&#123;&#123;theme.daovoice_app_id&#125;&#125;&quot; &#125;); daovoice(&apos;update&apos;); &lt;/script&gt;&#123;% endif %&#125; 3编辑主题配置文件，添加如下代码：123# Online contact daovoice: truedaovoice_app_id: daovoice_app_id 4, 效果图如下所示：]]></content>
      <categories>
        <category>个人博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO_博文置顶]]></title>
    <url>%2F2018%2F11%2F23%2FHEXO-%E5%8D%9A%E6%96%87%E7%BD%AE%E9%A1%B6%2F</url>
    <content type="text"><![CDATA[HEXO_博文置顶1,修改hexo-generator-index插件，把node_modules/hexo-generator-index/lib/generator.js中代码替换为：12345678910111213141516171819202122232425262728&apos;use strict&apos;;var pagination = require(&apos;hexo-pagination&apos;);module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || &apos;page&apos;; return pagination(&apos;&apos;, posts, &#123; perPage: config.index_generator.per_page, layout: [&apos;index&apos;, &apos;archive&apos;], format: paginationDir + &apos;/%d/&apos;, data: &#123; __index: true &#125; &#125;);&#125;; 2,文章添加Top值，值越大，越靠前：123456789---title: Hexo-NexT主题配置date: 2018-01-20 20:41:08categories: Hexotags:- Hexo- NexTtop: 100---]]></content>
      <categories>
        <category>个人博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO_添加jiathis分享]]></title>
    <url>%2F2018%2F11%2F22%2FHEXO-%E6%B7%BB%E5%8A%A0jiathis%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[HEXO_添加jiathis分享1编辑主题配置文件，将jiathis改为ture即可：1234567# Share# This plugin is more useful in China, make sure you known how to use it.# And you can find the use guide at official webiste: http://www.jiathis.com/.# Warning: JiaThis does not support https.jiathis: ture ##uid: Get this uid from http://www.jiathis.com/#add_this_id: 2,效果如下图所示：]]></content>
      <categories>
        <category>个人博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO_添加网页顶部进度加载条]]></title>
    <url>%2F2018%2F11%2F22%2FHEXO-%E6%B7%BB%E5%8A%A0%E7%BD%91%E9%A1%B5%E9%A1%B6%E9%83%A8%E8%BF%9B%E5%BA%A6%E5%8A%A0%E8%BD%BD%E6%9D%A1%2F</url>
    <content type="text"><![CDATA[HEXO_添加网页顶部进度加载条1,编辑主题配置文件，ctrl+f 搜索pace，将其值改为ture就可以了，选择一款你喜欢的样式。12345678910111213141516171819# Progress bar in the top during page loading.pace: tureThemes list:#pace-theme-big-counter#pace-theme-bounce#pace-theme-barber-shop#pace-theme-center-atom#pace-theme-center-circle#pace-theme-center-radar#pace-theme-center-simple#pace-theme-corner-indicator#pace-theme-fill-left#pace-theme-flash#pace-theme-loading-bar#pace-theme-mac-osx#pace-theme-minimal# For example# pace_theme: pace-theme-center-simplepace_theme: pace-theme-minimal]]></content>
      <categories>
        <category>个人博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO_实现文章统计功能]]></title>
    <url>%2F2018%2F11%2F22%2FHEXO-%E5%AE%9E%E7%8E%B0%E6%96%87%E7%AB%A0%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[HEXO_实现文章统计功能1安装Hexo插件，参考网站底部字数统计。2,编辑主题配置文件，配置如下：12345678# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true min2read: true totalcount: true separated_meta: true 3,效果图：]]></content>
      <categories>
        <category>个人博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO_设置网站的图标Favicon]]></title>
    <url>%2F2018%2F11%2F22%2FHEXO-%E8%AE%BE%E7%BD%AE%E7%BD%91%E7%AB%99%E7%9A%84%E5%9B%BE%E6%A0%87Favicon%2F</url>
    <content type="text"><![CDATA[HEXO_设置网站的图标Favicon1,在图标网站找一张你喜欢的图标（大：32x32 小：16x16），图标网站：easyicon或者阿里巴巴矢量图标库。将下载下来的小图和中图放在blog/themes/next/source/images，将默认的两张图片替换掉。命名和默认的一样也可以自己定义： 2,修改主题配置文件，如果你自定义了图片名字，需要做修改：123456789# For example, you put your favicons into `hexo-site/source/images` directory.# Then need to rename &amp; redefine they on any other names, otherwise icons from Next will rewrite your custom icons in Hexo.favicon: small: /images/favicon-16x16-next.png //16X16小图 medium: /images/favicon-32x32-next.png //32X32大图 apple_touch_icon: /images/apple-touch-icon-next.png //apple-touch-icon safari_pinned_tab: /images/logo.svg #android_manifest: /images/manifest.json #ms_browserconfig: /images/browserconfig.xml 3,修改后，效果如下：]]></content>
      <categories>
        <category>个人博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO_网站底部字数统计]]></title>
    <url>%2F2018%2F11%2F22%2FHEXO-%E7%BD%91%E7%AB%99%E5%BA%95%E9%83%A8%E5%AD%97%E6%95%B0%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[HEXO_网站底部字数统计1,安装hexo插件，切换到根目录：1npm install hexo-wordcount --save 2,在Blog/themes/next/layout/_partials/footer.swig末尾添加代码：1234&lt;div class=&quot;theme-info&quot;&gt; &lt;div class=&quot;powered-by&quot;&gt;&lt;/div&gt; &lt;span class=&quot;post-count&quot;&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;&lt;/div&gt; 3,效果图如下图所示：]]></content>
      <categories>
        <category>个人博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO_网站底部加上访问量]]></title>
    <url>%2F2018%2F11%2F22%2FHEXO-%E7%BD%91%E7%AB%99%E5%BA%95%E9%83%A8%E5%8A%A0%E4%B8%8A%E8%AE%BF%E9%97%AE%E9%87%8F%2F</url>
    <content type="text"><![CDATA[HEXO_网站底部加上访问量1,打开blog/themes/next/layout/_partials/footer.swig文件，在copyright加上如下代码：1&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 2,在适当的位置添加显示统计代码12345&lt;div class=&quot;powered-by&quot;&gt;&lt;i class=&quot;fa fa-user-md&quot;&gt;&lt;/i&gt;&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站访客数:&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt; 3设置统计方式123456789//pv的方式，单个用户连续点击n篇文章，记录n次访问量&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt; 本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt;//uv的方式，单个用户连续点击n篇文章，只记录1次访客数&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站总访问量&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;次&lt;/span&gt;]]></content>
      <categories>
        <category>个人博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO_主页文章添加阴影效果]]></title>
    <url>%2F2018%2F11%2F22%2FHEXO-%E4%B8%BB%E9%A1%B5%E6%96%87%E7%AB%A0%E6%B7%BB%E5%8A%A0%E9%98%B4%E5%BD%B1%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[HEXO_主页文章添加阴影效果1,打开blog\themes\next\source\css\_custom\custom.styl，添加以下代码：12345678// 主页文章添加阴影效果 .post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125; ###]]></content>
      <categories>
        <category>个人博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO_侧边栏社交小图标设置]]></title>
    <url>%2F2018%2F11%2F22%2FHEXO-%E4%BE%A7%E8%BE%B9%E6%A0%8F%E7%A4%BE%E4%BA%A4%E5%B0%8F%E5%9B%BE%E6%A0%87%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[HEXO_侧边栏社交小图标设置1,打开主题配置文件_config.yml，command+f搜索Social，将你有的社交账号前面的#号去掉。格式为：1[社交平台名]: [社交地址] || [图标名称] 12345678910111213#social: GitHub: https://github.com/yourname || github 简书: https://www.jianshu.com/xxxxxx || heartbeat 掘金: https://juejin.im/xxxxxxx || spinner #E-Mail: mailto:yourname@gmail.com || envelope #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skype 2,图标可以去Font Awesome Icon网站去找，找到后复制名字到相应的位置即可。]]></content>
      <categories>
        <category>个人博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO_修改代码块自定义样式]]></title>
    <url>%2F2018%2F11%2F22%2FHEXO-%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81%E5%9D%97%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[HEXO_修改代码块自定义样式1,打开Blog\themes\next\source\css\_custom\custom.styl，添加以下代码：123456789101112131415// Custom styles.code &#123; color: #ff7600; background: #fbf7f8; margin: 2px;&#125;// 大代码块的自定义样式.highlight, pre &#123; margin: 5px 0; padding: 5px; border-radius: 3px;&#125;.highlight, code, pre &#123; border: 1px solid #d6d6d6;&#125;]]></content>
      <categories>
        <category>个人博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO_设置头像并设置动画效果]]></title>
    <url>%2F2018%2F11%2F22%2FHEXO-%E8%AE%BE%E7%BD%AE%E5%A4%B4%E5%83%8F%E5%B9%B6%E8%AE%BE%E7%BD%AE%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[HEXO_设置头像并设置动画效果1,在blog/_config.yml中添加头像链接地址：12//添加头像地址avatar: [ http://....] 2,设置头像圆角并旋转，打开blog/themes/next/source/css/_common/components/sidebar/sidebar-author.styl，添加以下代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out;&#125;img:hover &#123; /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125;/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125;]]></content>
      <categories>
        <category>个人博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO_在文章末尾添加“文章结束标记]]></title>
    <url>%2F2018%2F11%2F22%2FHEXO-%E5%9C%A8%E6%96%87%E7%AB%A0%E6%9C%AB%E5%B0%BE%E6%B7%BB%E5%8A%A0%E2%80%9C%E6%96%87%E7%AB%A0%E7%BB%93%E6%9D%9F%E6%A0%87%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[HEXO_在文章末尾添加“文章结束标记1,在路径Blog\themes\next\layout\_macro文件夹中新建passage-end-tag.swig文件。12345//切换到路径_macrocd [_macro路径]//创建passage-end-tag.swig文件touch passage-end-tag.swig 2,在passage-end-tag.swig添加以下内容，直接用文本编辑器打开，粘贴以下内容后保存12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;-------------本文结束&lt;i class=&quot;fa fa-paw&quot;&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 3,打开blog\themes\next\layout\_macro\post.swig，在post-body之后，post-footer之前（post-footer之前两个DIV），添加以下代码：12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;passage-end-tag.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 4,添加位置，如下图所示： 5,修改主题配置文件_config.yml，在末尾添加：123# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true 6,配置完成之后，效果如下：]]></content>
      <categories>
        <category>个人博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO_修改底部标签样式]]></title>
    <url>%2F2018%2F11%2F22%2FHEXO-%E4%BF%AE%E6%94%B9%E5%BA%95%E9%83%A8%E6%A0%87%E7%AD%BE%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[HEXO_修改底部标签样式1,修改blog\themes\next\layout\_macro\post.swig中文件，ctrl+f搜索rel=&quot;tag&quot;&gt;#，将#替换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;。输入以下命令，查看效果：]]></content>
      <categories>
        <category>个人博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO_修改 hexo-theme-next 主题的样式]]></title>
    <url>%2F2018%2F11%2F22%2FHEXO-%E4%BF%AE%E6%94%B9-hexo-theme-next-%E4%B8%BB%E9%A2%98%E7%9A%84%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[HEXO_修改 hexo-theme-next 主题的样式1,首先，找到 博客根目录\themes\next\source\css\_custom\custom.styl 并打开它 （一下配置全部在这个文件里面进行） 第一步： 修改文章内链接文本样式往刚刚打开的那个文件里添加如下代码： 1234567891011// 文章内链接文本样式 .post-body p a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125; &#125; 第二步： 修改选中字符的颜色添加如下代码： 1234567891011// 修改选中字符的颜色/* webkit, opera, IE9 */::selection &#123; background: #00c4b6; color: #f7f7f7; &#125;/* firefox */::-moz-selection &#123; background: #00c4b6; color: #f7f7f7; &#125; 第三步： 修改网站头部的颜色继续添加如下代码： 123456789101112131415// 修改网站头部颜色.headband &#123; height: 3px; background: #49b1f5;&#125;.site-meta &#123; padding: 20px 0; color: #fff; background: #49b1f5;&#125;.site-subtitle &#123; margin-top: 10px; font-size: 13px; color: #ffffff;&#125; 第四步： 修改网站内按键（button）的样式继续： 123456789101112// 修改按键（button）样式.btn &#123; color: #49b1f5; background: #fff; border: 2px solid #49b1f5;&#125;// 按键（button）点击时样式.btn:hover &#123; border-color: #49b1f5; color: #fff; background: #49b1f5;&#125; 第五步： 鼠标移动至文章标题时的效果最后一步了： 12345678910111213141516171819// 鼠标移动至文章标题时的效果.posts-expand .post-title-link::before &#123; content: &quot;&quot;; position: absolute; width: 100%; height: 2px; bottom: 0; left: 0; background-color: #49b1f5; visibility: hidden; -webkit-transform: scaleX(0); -moz-transform: scaleX(0); -ms-transform: scaleX(0); -o-transform: scaleX(0); transform: scaleX(0); transition-duration: 0.2s; transition-timing-function: ease-in-out; transition-delay: 0s;&#125; 六 ：效果图：]]></content>
      <categories>
        <category>个人博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO_添加RSS]]></title>
    <url>%2F2018%2F11%2F22%2FHEXO-%E6%B7%BB%E5%8A%A0RSS%2F</url>
    <content type="text"><![CDATA[HEXO_添加RSS1,切换到Blog文件夹（hexo init的文件夹）下 1cd blog 2,安装Hexo插件 1npm install --save hexo-generator-feed 3,安装成功之后，编辑blog/_config.yml`文件，在文件末尾添加 123# Extensions## Plugins: http://hexo.io/plugins/plugins: hexo-generate-feed 4,配置主题_config.yml文件，command+f搜索rss，在后面加上/atom.xml 12//注意：有一个空格rss: /atom.xml 5,之后hexo g hexo d 部署到github上，效果图：]]></content>
      <categories>
        <category>个人博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO_在右上角或者左上角实现fork me on github]]></title>
    <url>%2F2018%2F11%2F22%2FHEXO-%E5%9C%A8%E5%8F%B3%E4%B8%8A%E8%A7%92%E6%88%96%E8%80%85%E5%B7%A6%E4%B8%8A%E8%A7%92%E5%AE%9E%E7%8E%B0fork-me-on-github%2F</url>
    <content type="text"><![CDATA[HEXO_在右上角或者左上角实现fork me on github1,在GitHub Ribbons或GitHub Corners选择一款你喜欢的挂饰，拷贝方框内的代码： 2,将刚刚复制的挂饰代码，添加到Blog/themes/next/layout/_layout.swig文件中，添加位置如下图所示(放在&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;下方)： 3,效果图如下图所示：]]></content>
      <categories>
        <category>个人博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO_设置动态背景]]></title>
    <url>%2F2018%2F11%2F22%2FHEXO-%E8%AE%BE%E7%BD%AE%E5%8A%A8%E6%80%81%E8%83%8C%E6%99%AF%2F</url>
    <content type="text"><![CDATA[HEXO_设置动态背景1,主题配置文件（_config.yml）中找到canvas_nest，设置成ture就OK啦。 12# Canvas-nestcanvas_nest: ture]]></content>
      <categories>
        <category>个人博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO_创建关于我页面]]></title>
    <url>%2F2018%2F11%2F22%2FHEXO-%E5%88%9B%E5%BB%BA%E5%85%B3%E4%BA%8E%E6%88%91%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[HEXO_创建关于我页面新建一个 about 页面： 1hexo new page &quot;about&quot; 菜单显示 about 链接，在主题的 _configy.yml 设置中将 menu 中 about 前面的注释去掉即可。 12345menu: home: / archives: /archives tags: /tags about: /about]]></content>
      <categories>
        <category>个人博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO_创建分类页面]]></title>
    <url>%2F2018%2F11%2F22%2FHEXO-%E5%88%9B%E5%BB%BA%E5%88%86%E7%B1%BB%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[HEXO_创建分类页面添加一个 分类 页面，并在菜单中显示页面链接。 新建一个页面，命名为 categories 。命令如下： 1hexo new page categories 编辑刚新建的页面，将页面的类型设置为 categories ，主题将自动为这个页面显示所有分类。 1234title: 分类date: 2014-12-22 12:39:04type: &quot;categories&quot;--- 注意：如果有启用多说 或者 Disqus 评论，默认页面也会带有评论。需要关闭的话，请添加字段 comments 并将值设置为 false，如： 12345title: 分类date: 2014-12-22 12:39:04type: &quot;categories&quot;comments: false--- 在菜单中添加链接。编辑主题的 _config.yml ，将 menu 中的 categories: /categories 注释去掉，如下: 12345menu: home: / categories: /categories archives: /archives tags: /tags]]></content>
      <categories>
        <category>个人博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO_创建标签云页面]]></title>
    <url>%2F2018%2F11%2F21%2FHEXO%E2%80%94-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AF%B9%E5%BA%94%E7%9A%84menu%E6%96%87%E4%BB%B6%E5%A4%B9%2F</url>
    <content type="text"><![CDATA[HEXO进阶(二)_创建标签云页面没有创建Menu对应的文件夹，Blog/source文件目录如下： 在博客网站点击标签菜单可能会提示： can not get tegs 比如要创建标签文件夹，终端中输入（前提在Hexo文件路径下） 123hexo new page &quot;tags&quot;输出：INFO Created: ~/Desktop/MyBlog/Blog/source/tags/index.md 成功过后目录如下： 编辑Blog/source/tags中index.md文件，添加type: &quot;tags&quot;，其他Menu也同理创建。 123title: tagsdate: 2018-01-20 18:57:48type: &quot;tags&quot; 在菜单中添加链接。编辑主题的 _config.yml ，添加 tags 到 menu 中，如下: 1234menu: home: / archives: /archives tags: /tags]]></content>
      <categories>
        <category>个人博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO_修改主题及网站配置]]></title>
    <url>%2F2018%2F11%2F21%2FHEXO_%E4%BF%AE%E6%94%B9%E4%B8%BB%E9%A2%98%E5%8F%8A%E7%BD%91%E7%AB%99%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[HEXO进阶(二)_修改主题及网站配置1，修改站点配置文件(_config.yml)注 ： 对应的目录 ：blog/_config.yml/，blog 为 hexo init 初始化文件夹的名称，替换成你自己初始化文件夹的名称。 修改 depoly ： 1234deploy: type: git repo: git@github.com:username.github.io.git branch: master repo的值是：登陆你的github，然后找到你创建的仓库，话不多说上图： 点击绿色标记的那个图标复制地址然后换到repo那里 注意要使用 UseSSH,不能用UseHttps。 2，修改主题默认的主题真的很捞，我们去换一个主题，这里我选用的是Next主题 通过 git 方式下载项目，命令如下 ： 12$ cd themes$ git clone https://github.com/iissnan/hexo-theme-next next 第一部步是进入到 themes 下面， 第二步是拷贝远程主题到该目录下。下载完成后，我的博客 themes 下就多了一个 next 文件夹。如图 ： 在站点文件夹中修改_config.yml ​ theme ：next 注 ：把默认主题 landscape 切换成 next。 3修改menu默认 menu 菜单显示 home、archives，根据自己的需要去掉注释。 4修改 Schemes ： next 主题对应的有四个风格，Muse、Mist、Pisces、Gemini，默认为 Muse。 根据自己的喜欢设置即可 5，编辑主题配置文件，启用自动摘录 :123auto_excerpt: enable: true length: 150 注 ：修改 auto_excerpt 为 true，允许自动摘录，显示部分，点击阅读全文。]]></content>
      <categories>
        <category>个人博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[devops前后端交互流程]]></title>
    <url>%2F2018%2F11%2F21%2Fdevops%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Devops前后端数据交互流程前言：本文以devops前端登陆功能来分析前后端数据交互的流程1，首先打开devops-web模块下的 2,login-normal.vue页面分析： 可以看到的是这个form引入了一个名为loginForm。我们跟踪源代码找到这个loginForm 可以看到这个form其实是定义了username和password的初始值。我们找到之前login-form的提交位置： 提交这个表单时会默认调用handleLogin这个方法我们去找到这个方法： 发现这个方法其实时调用了IUserController里面的login这个方法并且把username和password参数传入那么既然调用这个Controller，那么就绝对有导入相关Controller的配置我们找到： 现在我们明白时导入了action文件夹下面的controller我们切换到actions文件夹下面： 打开这个js文件发现里面定义了许多的Controller而我们的IUserController就在其中： 我们去api文件夹下面寻找IUserController： api文件夹下面定义了一系列的Controller IUserController也是定义在其中通过上图我们可以看到 url 和 parameters这俩个属性，parameters传入了username和password,url：正是去调用后端接口的地址：/api/uc/users/login去devops-specs下面找到IUserController这个接口： 我们发现这个接口的@Path的值刚好与之前的url相对应起来然后直接去调用login方法就可以了我们可以再找到IUserController的实现类 UserController： 到此，登陆功能从前端到后端的数据交互的流程已经分析完毕了，当然这只是大概的分析，具体的细节还要做进一步的研究。]]></content>
      <categories>
        <category>devops</category>
      </categories>
      <tags>
        <tag>devops</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Devops开发环境搭建及前后端交互流程]]></title>
    <url>%2F2018%2F11%2F21%2FDevops%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Devops - web模块环境搭建前言： ​ 安装nodejs npm 并且升级到最新版本。 一：解压源码包：​ 将devops源码包解压会得到如图所示的项目目录： ​ 二：将源码导入EOS-STUDIO中：(devops是一个maven工程，选择导入maven，将整个项目直接导入) 三：修改settings.xml文件打开刚刚导入的项目，打开pom.xml文件会发现报错 这是由于我们的setting.xml文件没有指定的缘故那么接下来我们就去设置setting.xml文件 (settings.xml文件在我们导入的项目devoper中) 点击首选项–&gt;选择Maven–&gt;UserSettings 设置上图所示的settings.xml路径 然后apply,确定，发现我们的pom文件没有报错了。 四：设置web模块的访问端口和ip地址打开devops-web模块–&gt;打开config下的index.js文件 host:改为localhost port:随意 五：安装依赖找到解压后的devops-web那个文件夹，点击进入。打开cmd执行 “npm install ”命令 执行之后会发现在该文件夹下会生成一个node_modules 六：修改webpack.dev.conf.js 打开webpack.dev.conf.js文件，把new CopyWebpackPlugin 里面的from字段的值改为上图所示的地址。 (不修改的话，在访问web模块时会报错) 七：启动并访问web模块找到解压后的devops-web那个文件夹，点击进入。打开cmd执行 “npm run dev ”命令 执行命令后会自动弹出页面我们只需稍等片刻。。。 OK至此为止，devops的web模块也就搭建完毕了。]]></content>
      <categories>
        <category>devops</category>
      </categories>
      <tags>
        <tag>devops</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO_初级搭建]]></title>
    <url>%2F2018%2F11%2F20%2FHEXO%E5%88%9D%E7%BA%A7%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[HEXO个人博客搭建（初级）相关步骤：1、安装Node.js和配置好Node.js环境，打开cmd命令行，成功界面如下 ： 2、安装Git和配置好Git环境，安装成功的象征就是在电脑上任何位置鼠标右键能够出现如下两个选择成功配置的界面如图 ： 3、Github账户注册和新建项目，项目必须要遵守格式：账户名.github.io，不然接下来会有很多麻烦。并且需要勾选Initialize this repository with a README ： 4、安装Hexo在自己认为合适的地方创个文件夹，我是在D盘建了一个blog文件夹。然后通过命令行进入到该文件夹里面 ： 在blog目录下，输入npm install hexo -g，开始安装Hexo ： 输入hexo -v，检查hexo是否安装成功 ： 输入hexo init，初始化该文件夹（waiting。。。。。） ： 看到最终执行完的的“Start blogging with Hexo！ 就成功了 输入npm install，安装所需要的组件 ： 输入hexo g，首次体验Hexo 输入hexo s，开启服务器，访问该网址，正式体验Hexo ：默认端口是 4000 那么出现如下图就成功了 5、将Hexo与Github page联系起来，设置Git的user name和email（如果是第一次的话） 邮箱和用户名替换成自己的 输入cd ~/.ssh，检查是否由.ssh的文件夹 输入ls，列出该文件下的内容。下图说明存在 输入ssh-keygen -t rsa -C “1219787757@qq.com”，连续三个回车，生成密钥，最后得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\Users\Administrator.ssh）。 输入eval “$(ssh-agent -s)”，添加密钥到ssh-agent 再输入ssh-add ~/.ssh/id_rsa，添加生成的SSH key到ssh-agent 登录Github，点击头像下的settings，添加ssh 新建一个new ssh key，将id_rsa.pub文件里的内容复制上去 输入ssh -T git@github.com，测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了 6、配置Deployment，在blog文件夹中，找到_config.yml文件，修改repo值（在末尾） repo值是你在github项目里的ssh（右下角） ：点击右面的那个图标按钮直接复制即可 7、新建一篇博客，在cmd执行命令：hexo new post “博客名” 这时候在文件夹_posts目录下将会看到已经创建的文件 （__post文件在blog/source下面可以找到）： 在生成以及部署文章之前，需要安装一个扩展：npm install hexo-deployer-git –save ： 使用编辑器编好文章，那么就可以使用命令：hexo d -g，生成以及部署了 ： 部署成功后访问你的地址：http://用户名.github.io。那么将看到生成的文章 ： 到此位置基础的HEXO+github就已经搭建完成了。]]></content>
      <categories>
        <category>个人博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
